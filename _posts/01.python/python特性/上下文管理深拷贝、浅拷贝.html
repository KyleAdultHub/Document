---
title: 上下文管理深拷贝、浅拷贝
date: "2016-11-26 22:00:00"
categories:
- python
- python特性
tags:
- python
toc: true
typora-root-url: ..\..\..
---

<html>
<body>
<div>
<span><div><font style="font-size: 14pt;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold; line-height: 18.399999618530273px;-evernote-highlight:true;">上下文管理器</span></span></font></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">上下文管理的应用</span></font></li><ul><li><span style="font-size: 9pt;">常用于一些资源操作，需要在资源的获取与释放的时候做相关的操作</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">常见使用上下文管理的场景</span></font></li><ul><li><span style="font-size: 9pt;">打开/关闭文件</span></li><li><span style="font-size: 9pt;">链接/关闭数据库</span></li><li><span style="font-size: 9pt;">网站的访问</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">上下文管理器</span></font></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">什么是上下文管理器</span></font></li><ul><li><span style="font-size: 9pt;">实现了上下文协议的对象/函数即为上下文管理器</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">上下文协议</span></font></li><ul><li><span style="font-size: 9pt;">当我们需要创建一个上下文管理器类的时候，就需要实现__enter__和__exit__方法，这对方法就称为上下文管理协议（Context Manager Protocol），定义了一种运行时上下文环境。</span></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">自定义一个上下文管理器类对象</span></font></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">示例：</font></span></li><ul><li><font style="font-size: 9pt;">class Contextor(object):</font></li><ul><li><font style="font-size: 9pt;">def __enter__(self):</font></li><ul><li><font style="font-size: 9pt;">pass</font></li></ul><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">def __exit__(self,*unused):</font></span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">pass</span></li></ul></ul></ul></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">定义一个上下文管理器函数</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">实现方法</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">使用contextlib库来实现函数类型的上下文管理器</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">示例：</span></li><ul><li><span style="font-size: 9pt;">@contextlib.contextmanager    </span></li><li><span style="font-size: 9pt;">def func():       </span></li><ul><li><span style="font-size: 9pt;">handle = MongoClient('127.0.0.1', 27017)    </span></li><li><span style="font-size: 9pt; line-height: 1.45;">yield   handle</span></li><li><span style="font-size: 9pt; line-height: 1.45;">handle.close( )</span></li></ul></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">创建方法</span></li><ul><li><span style="font-size: 9pt;">使用contextlib.contextmanager装饰上下文管理器函数    </span></li><li><span style="font-size: 9pt;">上下文管理器函数使用yield将代码段用到的对象返回    </span></li><li><span style="font-size: 9pt;">当上下文结束之后继续执行yield之后的工作</span></li></ul></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">上下文管理器的使用方法</span></li><ul><li><span style="font-size: 9pt;">with contextor [as var] : </span></li><ul><li><span style="font-size: 9pt;">with_body</span></li></ul><li><span style="font-size: 9pt;">备注：</span></li><ul><li><span style="font-size: 9pt;">contextor为上下文管理器，上下文管理器实现了上下文管理协议    </span></li><li><span style="font-size: 9pt;">var变量存放上下文管理器返回的内容    </span></li><li><span style="font-size: 9pt;">with_body为上下文过程中的处理代码</span></li><li><span style="font-size: 9pt;">with 关键字用于在代码块运行前进入上下文环境   </span></li><ul><li><span style="font-size: 9pt;">当使用上下文管理器对象的时候，上下文管理器就创建好了        </span><span style="font-size: 9pt; line-height: 1.45;">    </span></li><li><span style="font-size: 9pt;">与with搭配使用上下文管理器会加载调用__enter__方法，如果有as var从句，则将__enter__结果赋值给var    </span></li><li><span style="font-size: 9pt;">代码块执行结束触发调用__exit__    </span></li><li><span style="font-size: 9pt;">代码块执行异常触发调用__exit__，如果有返回False，这样异常会再代码块位置再触发一遍，程序会报错。</span></li></ul></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">常见的上下文管理器</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">类文件对象</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">创建数据库的句柄</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">线程的threading.Lock()  线程锁</span></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">socket 创建的套接字对象</span></font></li></ul></ul><div><font style="font-size: 14pt;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">赋值、浅拷贝、深拷贝</span></span></font></div></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">赋值操作</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">赋值操作原理</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">python中的赋值操作实际上就是引用的赋值与传递</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">示例：</span></li><ul><li><span style="font-size: 9pt;">a = [11,22]</span></li><li><span style="font-size: 9pt;">b = a      </span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">示例解释：</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">实际上就是将[11, 22]在内存中的地址赋给了a， 因此a将会指向[11. 22]，而b = a操作，则将a中存储的值赋给了b，所以a、被指向了同一个数据的引用</span></li><li><span style="font-size: 9pt;"><img src="/e_img/上下文管理深拷贝、浅拷贝_files/Image.png" type="image/png" data-filename="Image.png" width="268"/></span></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">浅拷贝操作</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">浅拷贝操作的原理</span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">python中的浅拷贝使用copy模块的copy方法，拷贝时创建一个新的数据对象，并拷贝对象内部数据的引用</font></span></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">如果拷贝的数据本身就是个不可变类型数据（比如元组），那么就只拷贝其引用</font></span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">示例：</span></li><ul><li><span style="font-size: 9pt;"><img src="/e_img/上下文管理深拷贝、浅拷贝_files/Image [1].png" type="image/png" data-filename="Image.png" width="288"/></span></li></ul><li><span style="font-size: 9pt;">常见的浅拷贝的场景</span></li><ul><li><span style="font-size: 9pt;">列表的切片</span></li><li><span style="font-size: 9pt;">字典的copy方法</span></li><li><span style="font-size: 9pt;">list( )的内置函数</span></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">深拷贝操作</span></font></li><ul><li><span style="font-size: 9pt;">深拷贝操作的原理</span></li><ul><li><span style="font-size: 9pt;">创建一个新的数据对象，对每个包含的数据进行递归的拷贝操作，当检测到拷贝的引用指向的是一个不可修改的对象时，那么拷贝对象的引用</span></li><li><span style="font-size: 9pt;">深拷贝是对数据对象的完全拷贝，当被拷贝的数据是可变类型将会复制其结构，深拷贝之后得到的结果与原数据没有任何的联系，任何对原数据的修改都不会影响深拷贝之后的数据</span></li></ul><li><span style="font-size: 9pt;">示例：</span></li><ul><li><span style="font-size: 9pt;"><img src="/e_img/上下文管理深拷贝、浅拷贝_files/Image [2].png" type="image/png" data-filename="Image.png" width="474"/></span></li></ul></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 1.45;">拷贝的特殊情况</span></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">拷贝元组数据</span></font></li><ul><li><span style="font-size: 9pt;">当元组中不含有可变类型数据的时候</span></li><ul><li><span style="font-size: 9pt;">copy.copy和copy.deepcopy的到的结果都是对拷贝内容的引用            </span></li><li><span style="font-size: 9pt;">eg:  a = (11,22)        </span></li></ul><li><span style="font-size: 9pt; line-height: 1.45;">当元组中含有可变类型数据</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">copy.copy拷贝的结果是引用</span></li><li><span style="font-size: 9pt; line-height: 1.45;">copy.deepcopy是深拷贝           </span></li><li><span style="font-size: 9pt; line-height: 1.45;">eg:  a = [11,22]  b = [33,44]</span></li><li><span style="font-size: 9pt; line-height: 1.45;">        c  =  (a,b)</span></li></ul></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">函数传参拷贝数据</span></font></li><ul><li><span style="font-size: 9pt;">函数传参的方法</span></li><ul><li><span style="font-size: 9pt;">def func（*args, **kwargs）</span></li><ul><li><span style="font-size: 9pt;">body</span></li></ul></ul><li><span style="font-size: 9pt;">函数传参的时候需要注意</span></li><ul><li><span style="font-size: 9pt;">默认传参只是会传递引用                       </span></li><li><span style="font-size: 9pt;">当参数为可变数据时(列表，字典等)，如果参数只使用而不修改，可直接传参，如果涉及到修改，函数内的修改会影响函数外的使用            </span></li><li><span style="font-size: 9pt;">如果想避免第二种情况，可以</span><span style="font-size: 9pt;">传递</span><span style="font-size: 9pt;">深拷贝数据来避免函数修改原来数据  </span>          </li></ul></ul></ul></ul></div><div><br/></div></span>
</div></body></html>