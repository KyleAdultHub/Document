---
title: 垃圾回收
date: "2016-09-27 22:00:00"
categories:
- python
- python特性
tags:
- python
toc: true
typora-root-url: ..\..\..
---

<html>
<body>
<div>
<span><div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">python的数据管理</span></font></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">python数据的创建</span></font></li><ul><li><span style="font-size: 9pt;">1.小整数对象池     范围[-5,256]   [a-z]  [A-Z]</span></li><ul><li><span style="font-size: 9pt;">整数在Python中的使用广泛，为了优化速度，使用小整数对象池来优化，小整数对象池中的数据不会被垃圾回收，单个字母也是同样原理            </span></li></ul><li><span style="font-size: 9pt; line-height: 1.45;">2.大整数对象       除了小整数对象</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">大整数用的频率低，所以使用时创建</span></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">pyhton数据管理机制</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">intern机制介绍（引用计数）</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">当重复创建若干变量（不可变类型），变量内容相同时，Python不会为相同的内容创建存储空间，而是使用引用计数的方式处理</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">字符串和数字类型的数据都是不可修改数据，每次的修改实际上是创建了一个新的对象</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">intern机制的特殊情况</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">字符串数据带空格</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">字符串数据如果存在空格则不共用数据</span></li><li><img src="/e_img/垃圾回收_files/Image.png" type="image/png" data-filename="Image.png" style="font-size: 9pt; line-height: 1.45;" width="256"/></li></ul></ul></ul></ul></div><div><font style="background-color: rgb(255, 250, 165); font-size: 14pt;-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">python的垃圾回收</span></font></div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">垃圾回收的概念</span></font></li><ul><li><span style="font-size: 9pt;">将不需要的数据进行回收，减少内存的占用</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">python的垃圾回收机制</span></font></li><ul><li><span style="font-size: 9pt;">1.主要运用引用计数跟踪和回收垃圾</span></li><li><span style="font-size: 9pt;">2.通过标记-清除辅助</span></li><li><span style="font-size: 9pt;">3.通过分代回收提高回收效率</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">垃圾回收机制详解</span></font></li><ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 15.199999809265137px;">python的回收机制</span></li><ul><li><span style="font-size: 9pt;">python里也同java一样采用了垃圾收集机制，不过不一样的是: python采用的是引用计数机制为主，分代收集机制为辅的策略</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">引用计数详解</span></font></li><ul><li><span style="font-size: 9pt;">引用计数的概念</span></li><ul><li><span style="font-size: 9pt;">python中所有的数据都是对象，在c语言中都是结构体(python的底层实现)，其中就有一个专门用于计数的参数，我们可以理解为Python类中在__init__初始化的时候定义了一个计数器</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">示例：</span></li><ul><li><span style="font-size: 9pt;"><img src="/e_img/垃圾回收_files/Image [1].png" type="image/png" data-filename="Image.png" width="278"/></span></li></ul></ul><li><span style="font-size: 9pt;">引用计数回收机制的优缺点</span></li><ul><li><span style="font-size: 9pt;">优点</span></li><ul><li><span style="font-size: 9pt;">简单</span></li><li><span style="font-size: 9pt;">实时性：一旦没有引用(引用计数为0)，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。</span></li></ul><li><span style="font-size: 9pt; line-height: 1.45;">缺点</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">维护引用计数消耗资源</span></li><li><span style="font-size: 9pt; line-height: 1.45;">循环引用（用分代收集来弥补）</span></li></ul></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">引用计数与其他回收方式的对比</span></li><ul><li><span style="font-size: 9pt;">ruby的垃圾回收原理</span></li><ul><li><span style="font-size: 9pt;">1.ruby会提前创建一个链表型存储空间链</span></li><li><span style="font-size: 9pt;"><img src="/e_img/垃圾回收_files/Image [2].png" type="image/png" data-filename="Image.png" width="288"/></span></li><li><span style="font-size: 9pt;">2.当需要存储空间的时候去链表上拿取一块空间用于存储数据</span></li><li><span style="font-size: 9pt;"><img src="/e_img/垃圾回收_files/Image [3].png" type="image/png" data-filename="Image.png" width="255"/></span></li><li><span style="font-size: 9pt;">3.持续创建变量消耗存储空间</span></li><li><span style="font-size: 9pt;"><img src="/e_img/垃圾回收_files/Image [4].png" type="image/png" data-filename="Image.png" width="268"/></span></li><li><span style="font-size: 9pt;">4.直到消耗完毕预定义的存储空间</span></li><li><span style="font-size: 9pt;">5.之后停止程序一小段事件进行垃圾回收，回收已经没有引用的空间</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">python垃圾回收原理</span></li><ul><li><span style="font-size: 9pt;">1.Python需要存储空间的时候向系统申请</span></li><li><span style="font-size: 9pt;">n1 = ‘abc’  <img src="/e_img/垃圾回收_files/Image [5].png" type="image/png" data-filename="Image.png" width="94"/></span></li><li><span style="font-size: 9pt;">2.当创建若干个变量的时候</span></li><li style="text-align: left;"><span style="font-size: 9pt;">n1 = ‘abc’  <img src="/e_img/垃圾回收_files/Image [6].png" type="image/png" data-filename="Image.png" width="96"/></span></li><li style="text-align: left;"><span style="font-size: 9pt;">n2 = ‘def’ <img src="/e_img/垃圾回收_files/Image [7].png" type="image/png" data-filename="Image.png" width="97"/></span></li><li style="text-align: left;"><span style="font-size: 9pt;">n3 = ‘hij’   <img src="/e_img/垃圾回收_files/Image [8].png" type="image/png" data-filename="Image.png" width="101"/></span></li><li style="text-align: left;"><span style="font-size: 9pt;">3.创建新的对象并赋值给旧变量</span></li><li style="text-align: left;"><span style="font-size: 9pt;">n1 = ‘abc’    n1 = ‘klm’</span></li><li style="text-align: left;"><span style="font-size: 9pt;"><img src="/e_img/垃圾回收_files/Image [9].png" type="image/png" data-filename="Image.png" width="322"/></span></li><li style="text-align: left;"><span style="font-size: 9pt;">4.引用计数为0的对象不久就会被系统的自动回收</span></li></ul></ul></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">标记-清除&amp;分代回收</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">引入分代回收的原因</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">用来处理引用计数有问题的内存空间，比如数据之间存在循环引用（即双方互相引用），这样会导致资源没有被其他的变量引用，但是数据的引用计数不为0，导致资源不能被普通的引用计数的方法回收，这时就要使用分代回收来处理</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">作用场景</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">当出现循环引用的时候，在某些情况下，有可能程序员的代码会造成循环引用，类似于线程的死锁，这样就呆滞了空间无法及时清退，造成空间的占用</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">分代回收的原理</span></li><ul><li><span style="font-size: 9pt;">1.将每个对象放到一个列表中(零代列表)        </span></li><li><span style="font-size: 9pt;">2.检查列表中的每一项之间是否存在相互引用，如果存在则根据算法去除，并且修改引用计数        </span></li><li><span style="font-size: 9pt;">3.释放列表中引用计数为0的对象        </span></li><li><span style="font-size: 9pt;">4.将经过检测的对象放入另一个列表中(一代列表)        </span></li><li><span style="font-size: 9pt;">5.经过一定时间按照检测零代列表的方式检测一代列表中的对象</span></li><li><span style="line-height: 13.600000381469727px;">备注：后面每一代列表的检测频率会低于前面的列表</span></li></ul></ul></ul></ul><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 14pt;"><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">python的垃圾回收相关模块</span></font></span></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">查询对象的引用计数</span></font></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">import sys    导入sys模块</span></font></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">sys.getrefcount(n)       获取对象的引用计数（注意，</span><span style="font-size: 9pt; line-height: 13.600000381469727px;">sys.getrefcount本身也会引用一次</span><span style="font-size: 9pt; line-height: 13.600000381469727px;">）</span></font></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">del  变量      删除变量，将引用计数减一</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">设置垃圾回收的相关操作</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">import   gc    导入gc模块</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">gc.disable()      关闭垃圾回收,主要关闭分代回收</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">gc.collect()       手动回收垃圾，主要实现了分代回收的功能</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">gc.get_threshold()      查看垃圾回收的阈值</span></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">gc.get_count()        查看当前内存分配的垃圾回收计数</span></font></li></ul></ul></div><div><br/></div></div><div><br/></div></span>
</div></body></html>