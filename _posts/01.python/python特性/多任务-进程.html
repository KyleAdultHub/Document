---
title: 多任务-进程
date: "2016-11-05 22:00:00"
categories:
- python
- python特性
tags:
- python
toc: true
typora-root-url: ..\..\..
---


<html>
<body>
<div>
<span><div><span style="font-size: 18.399999618530273px;background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 18.4px; color: rgb(50, 135, 18); font-weight: bold; line-height: 21.6px;-evernote-highlight:true;">进程</span></span></div><div><ul><li><div><span style="font-size: 12pt; font-weight: bold; line-height: 1.45;">进程的概念</span></div></li><ul><li><div><span style="font-size: 9pt;">进程的概念：进程是一个具有独立功能的程序的一次运行活动，是操作系统的资源分配的基本单位</span></div></li><ul><li><div><span style="font-size: 9pt; line-height: 1.45;">一个shell（linux命令）是一个系统目录下的程序，当使用某个命令时，系统为我们创建了一个进程运行这个程序</span></div></li></ul><li><div><span style="font-size: 9pt;">僵尸进程：子进程已经运行完成结束， 但是父进程还没有来得及对子进程的相关资源进行回收</span></div></li><ul><li><div><span style="font-size: 9pt;">不回收的话对系统资源的影响比较大</span></div></li></ul><li><div><span style="font-size: 9pt;">孤儿进程：父进程退出， 子进程还没有退出  子进程就变成孤儿进程</span></div></li><ul><li><div><span style="font-size: 9pt;">init进程接管孤儿进程 init进程负责回收孤儿进程的资源</span></div></li></ul></ul></ul></div><div><div><ul><li><div><span style="font-size: 12pt; font-weight: bold; line-height: 1.45;">进程的三个典型状态</span></div></li><ul><li><div><img src="/e_img/多任务-进程_files/Image.png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="351"/></div></li><li><div><span style="font-size: 9pt; line-height: 1.45;">就绪：已经分配除CPU之外所有的资源</span></div></li><li><div><span style="font-size: 9pt; line-height: 1.45;">运行：正在占用CPU资源执行</span></div></li><li><div><span style="font-size: 9pt; line-height: 1.45;">阻塞：正在等待事件/数据的条件</span></div></li></ul></ul></div><ul><li><div><span style="font-size: 12pt; font-weight: bold; line-height: 1.45;">进程与程序的区别</span></div></li><ul><li><div><span style="font-size: 9pt; line-height: 1.45;">进程与程序拥有资源的区别：</span></div></li><ul><li><div><span style="font-size: 9pt;">程序：占用硬盘空间，以程序/二进制代码的形式存储在硬盘中</span></div></li><li><div><span style="font-size: 9pt;">进程：占用内存/CPU等资源，程序运行一次活动会占用内存和CPU的资源</span></div></li></ul></ul></ul></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">单任务/多任务</span></font></div><div><ul><li><div><span style="font-size: 9pt;">单任务：串行执行效率低</span></div></li><ul><li><div><span style="font-size: 9pt;">多任务：就是操作系统同时运行多个任务，可以充分利用cpu的多核，这样执行代码的效率高，也可以实现一些需要同时运行的代码逻辑</span></div></li></ul></ul><div><br/></div><div>        <img src="/e_img/多任务-进程_files/Image [1].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="199"/></div><div><br/></div></div><div><br/></div><div><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">并行与并发：</span></font></div><div><ul><li><div><span style="font-size: 9pt;">并行：多个任务在同一时刻执行,指的是当任务数小于cpu核数的时候，任务可以利用多核完成一起执行</span></div></li><li><div><span style="font-size: 9pt;">并发：多个任务在同一个时间段执行</span><span style="font-size: 9pt; line-height: 1.45;">,指的是当cpu任务书多余cpu核数的时候，通过操作系统的各种任务调度算法，实现多个任务 一起执行（但是实际上不是同一时刻执行因为cpu的切换任务的速度特别快，在效果上看相当于在一起执行</span><span style="font-size: 9pt; line-height: 1.45;">）</span></div></li></ul></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">操作系统中进程的PID标示</span></font></div><div><ul><li><div><span style="font-size: 9pt;">PID（Process identification）是一个进程在操作系统中的唯一标示，每次程序运行操作系统会随机分配一个PID号给到对应进程，不能通过直接指定的方式来确定PID标示。</span></div></li><li><div><span style="font-size: 9pt;">获取PID进程标示的方法：</span></div></li><ul><li><div><span style="font-size: 9pt;">ps -aux | grep process name      获取所有进程的信息</span></div></li><li><div><span style="font-size: 9pt;">os.getpid()      获取当前进程的PID</span></div></li><li><div><span style="font-size: 9pt;">进程的实例.pid      获取创建出来的子进程的PID</span></div></li></ul></ul></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">multiprocessing跨平台多进程模块使用</span></font></div><div><ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">multiprocessing</span></font></div></li><ul><li><div><span style="font-size: 9pt;">multiprocessing是跨平台的多进程模块，用来进行多进程软件的开发</span></div></li></ul></ul></div><div><ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold; line-height: 1.45;">multiprocessing.Process类</span></font></div></li><ul><li><div><span style="font-size: 9pt;">作用</span></div></li><ul><li><div><span style="font-size: 9pt;">通过创建multiprocessing.Process的实例可以创建对应的子进程，通过对实例的控制可以实现对子进程的操作</span></div></li></ul><li><div><span style="font-size: 9pt; line-height: 13.6px;">创建Process子进程实例</span></div></li><ul><li><div><span style="font-size: 9pt;">process_object = multiprocessing.Process(target=None, args=(), name=&quot;&quot;)</span></div></li></ul><li><div><span style="font-size: 9pt;">创建Process类的实例时__init__方法常用参数</span></div></li><ul><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.6px;">target  表示子线程入口函数代码None表示nothing</span></font></div></li><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.6px;">args  表示入口代码运行所需要的参数元组              args把数据传递给普通形参</span></font></div></li><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.6px;">kwargs  <span style="font-size: 9pt; line-height: 13.6px;">表示入口代码运行所需要的参数字典          kwargs 把数据传递给缺省参数</span></span></font></div></li><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.6px;">name  指定进程的名称，也可以不指定，系统会自动分配</span></font></div></li></ul><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.6px;">Process 实例常用方法和属性</span></font></div></li><ul><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.6px;">start（）  启动进程</span></font></div></li><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.6px;">is_alive() 判断进程是否还存活</span></font></div></li><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.6px;">join（time）  阻塞程序（子进程结束后才能继续主进程），加time可以设置等待时间，不写time的值默认等待到条件满足</span></font></div></li><ul><li><div><span style="font-size: 9pt; line-height: 13.6px;">在设计多进程的时候最好都要用join来回收内存资源，不然会造成僵尸程序</span></div></li></ul><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.6px;">terminate（）  终止子进程  -  会让子进程变成僵尸程序，需要注意要用join（）来回收进程资源</span></font></div></li><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.6px;">name  进程的名称</span></font></div></li><li><div><span style="font-size: 9pt; line-height: 13.6px;">pid  进程的PID号</span></div></li></ul><li><div><span style="font-size: 9pt; line-height: 13.6px;">（注意：在进程中默认已经有一个进程了（主进程））</span></div></li></ul><li><div><span style="background-color: rgb(255, 255, 255);"><font style="font-size: 12pt;"><span style="font-size: 12pt; background-color: rgb(255, 255, 255); font-weight: bold; line-height: 13.6px;">父子进程关于数据的共享</span></font></span></div></li><ul><li><div><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.6px;">父子进程在独立的内存地址空间，并不能直接进行全局数据的共享</span></font></div></li><li><div><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.6px;">在创建子进程的时候会将父进程中的数据复制一份到子进程中，后面的运行数据是独立状态的</span></font></div></li></ul><li><div><font style="font-size: 12pt;"><span style="background-color: rgb(255, 255, 255);"><span style="font-size: 12pt; background-color: rgb(255, 255, 255); font-weight: bold; line-height: 13.6px;">multiprocessing-Queue方法（进程间的通信）</span></span></font></div></li><ul><li><div><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.6px;">作用：通过创建Queue列队，可以在进程间通过传递Queue列队来传递进程间的参数</span></font></div></li><li><div><span style="line-height: 13.6px;">列队的特点：先进先出，后进后出</span></div></li><li><div><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.6px;">创建queue列队</span></font></div></li><ul><li><div><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.6px;"> 变量名 = multiprocessing.Queue（maxsize）        maxsize参数表示列队的容量，当maxsize为0的时候标示列队的容量为无穷大（慎用）</span></font></div></li></ul><li><div><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.6px;">Queue实例对象常用方法<span style="font-size: 12px; line-height: 13.6px;">（假设已经创建实例名为q）</span></span></font></div></li><ul><li><div><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.6px;">添加数据到列队</span></font></div></li><ul><li><div><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.6px;">q.put(obj, block=True, timeout=None) </span></font></div></li><ul><li><div><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.6px;">block 默认为True表示阻塞状态列队满了会阻塞，False为非阻塞状态，列队满后会报错；    timeout参数只对阻塞模式有效，等待响应时间如无响应会继续向下执行代码；</span></font></div></li></ul></ul><li><div><span style="font-size: 12px; line-height: 13.6px;">从列队中取出数据</span></div></li><ul><li><div><span style="font-size: 12px;">q.get(</span><span style="font-size: 12px;">block=True, timeout=None</span><span style="font-size: 12px;">)</span><span style="font-size: small; line-height: 13.6px;">   参数同put方法</span></div></li></ul><li><div><span style="font-size: small; line-height: 13.6px;">获取列队中的消息数量</span></div></li><ul><li><div><span style="font-size: small; line-height: 13.6px;">q.size( )</span></div></li></ul><li><div><span style="font-size: small; line-height: 13.6px;">判断列队是否为空/满</span></div></li><ul><li><div><span style="font-size: small; line-height: 13.6px;">q.empty( )/ q.full( )       返回True/False</span></div></li></ul></ul><li><div><span style="line-height: 13.6px;">文件信息传递实例</span></div></li><ul><li><div><img src="/e_img/多任务-进程_files/Image [2].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="261"/></div></li></ul></ul></ul><div><ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">multiprocessing.Pool （类）进程池</span></font></div></li><ul><li><div><span style="font-size: 9pt;">进程池：</span></div></li><ul><li><div><span style="font-size: 9pt;">提前缓存一定的资源，以备不时之需重复的使用</span></div></li></ul><li><div><span style="font-size: 9pt;">优点： </span></div></li><ul><li><div><span style="font-size: 9pt;">节约等待和销毁资源的时间</span></div></li></ul><li><div><span style="font-size: 9pt;">建立进程池与常用方法</span></div></li><ul><li><div><span style="font-size: 9pt;">创建进程池</span></div></li><ul><li><div><span style="font-size: 9pt;">pool_object = multiprocessing.Pool(processes=None)   process表示进程池的容量    进程满后将会阻塞，直到有进程结束并成功向资源池中添加进程后</span></div></li></ul><li><div><span style="font-size: 9pt;">向进程池中添加任务</span></div></li><ul><li><div><span style="font-size: 9pt;">pool_object.apply(func, args=())   以阻塞的方式向进程池中添加任务</span></div></li><ul><li><div><span style="font-size: 9pt;">特点：添加到进程池中的任务会加到任务列队中等待上一个任务结束后会执行新的任务，实际上apply（）方法是依赖apply_async的底层实现的，在其方法上增加了get（）的函数，使添加任务的时候会默认阻塞等待上一个进程结束</span></div></li></ul><li><div><span style="font-size: 9pt;">pool_object.apply_async(func, args=())   以非阻塞的方式向进程池中添加任务</span></div></li><ul><li><div><span style="font-size: 9pt;">特点：将任务添加到任务列队中，进程池中的任务会并发执行，不会等上一个任务结束再进行下一个任务</span></div></li></ul></ul><li><div><span style="font-size: 9pt;">关闭进程池</span></div></li><ul><li><div><span style="font-size: 9pt;">pool_object.close()    关闭进程池后  进程池将不能够再接受新的任务</span></div></li></ul><li><div><span style="font-size: 9pt;">终止进程池</span></div></li><ul><li><div><span style="font-size: 9pt;">pool_object.terminate()</span></div></li></ul><li><div><span style="font-size: 9pt;">阻塞进程池</span></div></li><ul><li><div><span style="font-size: 9pt;">pool_object.join()</span></div></li><li><div><span style="font-size: 9pt;">注意：</span><span style="font-size: 9pt; font-weight: bold;">要先关闭或者终止进程池</span><span style="font-size: 9pt;">，然后再join（）</span></div></li></ul></ul><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 1.45;">进程池间进程的通信方法---</span><span style="font-size: 9pt; line-height: 1.45;">multiprocessing.Manager( ).Queue( )</span></font></div></li><ul><li><div><span style="font-size: 9pt; line-height: 1.45;">使用Queue时的限制：</span></div></li><ul><li><div><span style="font-size: 9pt; line-height: 1.45;">具有共同祖先</span></div></li><li><div><span style="font-size: 9pt; line-height: 1.45;">由于进程池中的任务是调用进程池的方法来创建的进程，他们的父进程并不统一，不能使用Queue来进行通信</span></div></li></ul></ul></ul></ul></div></div><div><font style="font-size: 14pt;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold; line-height: 13.6px;-evernote-highlight:true;">备注：文件相关操作</span></span></font></div><div><ul><li><div><span style="font-size: 9pt;">os.path.getsize(文件名 )  获取文件的大小</span></div></li><li><div><span style="font-size: 9pt;">os.path.getmtime/ctime(文件名 )  获取文件的修改时间</span></div></li></ul></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">拓展-MP中的几个函数</span></font></div><div><ul><li><div><span style="font-size: 9pt;">返回当前系统的可用的逻辑处理核心数</span></div></li><ul><li><div><span style="font-size: 9pt;">multiprocessing.cpu_count()</span></div></li></ul><li><div><span style="font-size: 9pt;">返回当前的Process实例</span></div></li><ul><li><div><span style="font-size: 9pt;">multiprocessing.current_process()</span></div></li></ul><li><div><span style="font-size: 9pt; line-height: 1.45;">返回当前进程的子进程列表</span></div></li><ul><li><div><span style="font-size: 9pt;">multiprocessing.active_children()</span></div></li></ul></ul></div><div><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">注意点：</span></div><div><ul><li><div><span style="font-size: 9pt;">不能再子进程中使用input（），会报错，若要使用需要关闭父进程的文件标识符</span></div></li></ul></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html>