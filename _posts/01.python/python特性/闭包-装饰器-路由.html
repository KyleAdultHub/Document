---
title: 闭包 装饰器 路由
date: "2016-09-14 22:00:00"
categories:
- python
- python特性
tags:
- python
toc: true
typora-root-url: ..\..\..
---

<html>
<body>
<div>
<span><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">闭包  --装饰器的前提</span></font></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 1.45;">闭包的介绍</span></font></li></ul></div><div><ul><ul><li><span style="font-size: 9pt;">闭包的概念</span></li><ul><li><span style="font-size: 9pt;">函数式编程的重要的语法结构。</span></li><li><span style="font-size: 9pt;">闭包（Closure）是由</span><span style="font-size: 9pt; font-weight: bold;">函数</span><span style="font-size: 9pt;">和与</span><span style="font-size: 9pt; font-weight: bold;">其相关的引用环境（在闭包中使用的装饰器中的变量）</span><span style="font-size: 9pt;">组合而成的实体（对象）。</span></li><li><span style="font-size: 9pt;">这个被引用的</span><span style="font-size: 9pt; font-weight: bold;">自由变量</span><span style="font-size: 9pt;">将和这个</span><span style="font-size: 9pt; font-weight: bold;">函数</span><span style="font-size: 9pt;">一同存在，即使已经离开了创造它的环境也不例外。</span></li></ul><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">闭包的特点</span></li><ul><li><span style="font-size: 9pt;">定义在函数内部并使用外部函数提供的环境变量</span></li><li><span style="font-size: 9pt;">闭包不是简单的函数，可以根据不同环境产生不同函数对象实例（每一次引用闭包都会创建一个不同闭包实例）</span></li></ul><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">作用</span></li><ul><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">可以不更改函数的逻辑代码，通过闭包来实现对函数功能的拓展。</span></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">闭包实例的使用方法</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">闭包的使用方式</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">建立一个含有闭包的函数（装饰器）</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">调用装饰器函数，返回一个闭包的实例（实例中包含了环境变量和函数）</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">调用闭包实例执行</span></li><li><span style="font-size: 9pt;"><img src="/e_img/闭包-装饰器-路由_files/Image.png" type="image/png" data-filename="Image.png" width="328"/></span></li></ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">闭包存在的属性</font></span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">__closure__  属性   </font></span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">“其中包含了所有环境变量的引用于同一个元组中，  可以通过对该实例属性的修改来完成修改环境变量”</font></span></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">对于环境变量有cell_contents 方法， 用来表明变量对象中包含的内容类型和名称等</font></span></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">注：元组中的第一位为创建出的闭包实例的引用，后面为对象的环境变量的引用</font></span></li></ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">__name__  属性  </font></span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">“表示该闭包实例的名称，默认为闭包函数名， 可以通过修改该属性来表示闭包所关联的函数，方便区分闭包”</font></span></li></ul></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">闭包修改环境变量</span></li><ul><li><span style="font-size: 9pt;">py2 和py3修改环境变量的方式</span></li><ul><li><span style="font-size: 9pt;">python3 修改环境变量的方法</span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">使用nonlocal来声明下面出现的变量都不是环境变量，是在外边的函数中的变量；</font></span></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">修改变量的时候不会在局部空间创建地址，会寻找对应的环境变量(不包括全局变量)来进行修改</font></span></li></ul><li><font style="font-size: 9pt;">python2 修改环境变量的方法</font></li><ul><li><font style="font-size: 9pt;">py2则需要 将环境数据包装在列表中</font></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">然后通过对列表的增删改来达到修改外部变量的目的</font></span></li></ul></ul></ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">闭包装饰器</font></span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">包含了闭包的函数极称为装饰器函数，即为下面实例的gettime函数，返回的是被装饰的 func的函数对象即为inner</font></span></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-weight: bold; line-height: 13.600000381469727px;">闭包的实例</span></font></li><ul><li><span style="font-size: 9pt;"><img src="/e_img/闭包-装饰器-路由_files/Image [1].png" type="image/png" data-filename="Image.png" width="298"/></span></li></ul></ul></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 14pt;"><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">更进一步的@语法糖--装饰器</span></font></span></div><div><ul><li><span style="font-size: 9pt; font-weight: bold;">例子</span><span style="font-size: 9pt;">：</span></li><ul><li><span style="font-size: 9pt;"><img src="/e_img/闭包-装饰器-路由_files/Image [2].png" type="image/png" data-filename="Image.png" width="361"/></span></li><li><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.600000381469727px;">备注：</span></font></li><ul><li><span style="font-size: 9pt;">func函数可能有参数</span></li><ul><li><span style="font-size: 9pt;">给inner增加需要参数 *args,**kwargs</span></li></ul><li><span style="font-size: 9pt; line-height: 1.45;">func可能有返回值</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">暂存func的返回值 ret（如果需func的返回值的话，不单单是执行func）</span></li><li><span style="font-size: 9pt; line-height: 1.45;">在inner中最后return ret</span></li></ul></ul></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 1.45;">作用：</span></font></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">@gettime ==》 func = gettime（func） “如果用了@语法，py解释器会自动的执行其对应的含义，不需要代码去对其进行启动”</span></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 1.45;">定义函数的时候直接用@装饰器函数，可以对代码进行修饰</span></font></li><li><span style="font-size: 9pt; line-height: 1.45;">用户使用装饰后的代码时，会与代码的修改无感知（既然从使用上不会造成什么改变，但是执行结果上已经被修饰过）</span></li></ul></ul></div><div><font style="font-size: 14pt;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">装饰器工厂</span></span></font></div><div><ul><li><font style="font-size: 9pt;"><span style="font-weight: bold; line-height: 13.600000381469727px;">概念</span></font></li><ul><li><font style="font-size: 9pt;"><span style="line-height: 13.600000381469727px;">从前面的了解可以知道，创建闭包的外部函数就叫装饰器</span></font></li><li><font style="font-size: 9pt;">而装饰器工厂可以理解为生产装饰器的函数</font></li></ul><li><span style="font-weight: bold; line-height: 13.600000381469727px;"><font style="font-size: 9pt;">作用：</font></span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">现有装饰器只能接受被装饰函数作为参数，不能接收其他参数</font></span></li><li><font style="font-size: 9pt;">创建一个装饰器工厂函数根据参数不同返回不同的装饰后的函数（就是装饰器只能传入函数为参数，所以想要传入其他参数需要用装饰器工厂来传入）。</font></li></ul><li><font style="font-size: 9pt;"><span style="font-weight: bold; line-height: 13.600000381469727px;">特征：</span></font></li><ul><li><font style="font-size: 9pt;">返回值为装饰器对象</font></li><li><font style="font-size: 9pt;">可以根据不同的参数对执行代码进行不同的配置</font></li></ul><li><font style="font-size: 9pt;"><span style="font-weight: bold; line-height: 13.600000381469727px;">例子：</span></font></li><ul><li><img src="/e_img/闭包-装饰器-路由_files/Image [3].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="345"/></li></ul><li><font style="font-size: 9pt;"><span style="font-weight: bold; line-height: 13.600000381469727px;">@语法在此处的作用</span></font></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">get_run_time(True) ==&gt; func = get_run_time(True)(func)</font></span></li></ul><li><font style="font-size: 9pt;"><span style="font-weight: bold; line-height: 13.600000381469727px;">装饰器工厂的一种用法</span></font></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">给web服务器添加路由</font></span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">实现了通过给装饰器工程传入不同的文件和函数的匹配信息，完成不同的装饰效果</font></span></li><li><font style="font-size: 9pt;"><img src="/e_img/闭包-装饰器-路由_files/Image [4].png" type="image/png" data-filename="Image.png" width="285"/></font></li></ul></ul></ul></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">装饰器的副作用</span></font></div><div><ul><li><font style="font-size: 9pt;"><span style="font-weight: bold;">影响</span>：</font></li><ul><li><font style="font-size: 9pt;">被装饰之后的函数本质上已经不是原函数（比如上例func的__name__已经不是func，而是inner，因为实际上，现在func是通过inner内部实现的）</font></li></ul><li><font style="font-size: 9pt;"><span style="font-weight: bold; line-height: 13.600000381469727px;">解决办法：</span></font></li><ul><li><font style="font-size: 9pt;">在装饰器内的内部函数（inner）定义时加上一个特殊的装饰器 functools.wraps(func)</font></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">备注：实际上还是在inner的实例中调用func，但是只是把inner实例的__name__属性强行变为func</font></span></li></ul></ul><div><font style="font-size: 14pt;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">装饰器的作用--总结</span></span></font></div><div><ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 1.45;">AOP面向切面编程</span></li><ul><li><span style="font-size: 9pt;">将业务实现和其他细节隔离开</span></li><ul><li><span style="font-size: 9pt;">切面就是业务实现</span></li><li><span style="font-size: 9pt;">其他相关细节（酱料等）就是关注点</span></li><ul><li><span style="font-size: 9pt;">比如计时、记录日志、事务处理</span></li></ul></ul></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">分离代码逻辑</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">说白了就是将函数的主要逻辑代码和辅助功能的代码分离开，实际执行的时候通过装饰器将函数主要逻辑代码和辅助功能代码进行结合，这时候就要重新规定装饰后代码的返回值，因为最后的返回值是闭包函数执行后的返回结果</span></li></ul></ul></div><div><br/></div></div><div><br/></div><div><br/></div></span>
</div></body></html>