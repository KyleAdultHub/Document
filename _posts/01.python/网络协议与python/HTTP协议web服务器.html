---
title: HTTP协议web服务器
date: "2016-09-14 22:00:00"
categories:
- python
- 网络协议与python
tags:
- python
- 网络协议
toc: true
typora-root-url: ..\..\..
---

<html>
<body>
<div>
<span><div><div><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">HTTP协议的介绍</span></div><ul><li><span style="font-size: 9pt; font-weight: bold;">3W标准</span></li><ul><li><span style="font-size: 9pt;">万维网(world wide web，WWW)是互联网中最常用服务。 WWW制定了一套标准 : 超文本标记语言HTML、统一资源定位器URL和超文本传送协议HTTP。起源于1989年3月</span></li></ul><li><span style="font-size: 9pt; font-weight: bold;">HTM与 css\Jacasctrpt介绍</span></li><ul><li><font style="font-size: 9pt;">HTML的介绍</font></li><ul><li><font style="font-size: 9pt;">超文本标记语言（HyperText Markup Language）是一种用于创建网页的标准标记语言，用同一种规则在web上进行数据传输</font></li><li><font style="font-size: 9pt;">浏览器可以读取HTML文件将其渲染成网页</font></li><li><font style="font-size: 9pt;">在实际应用场景中 HTML常与CSS、JavaScript一起被众多网站用于设计令人赏心悦目的网页。</font></li></ul><li><font style="font-size: 9pt;">CSS</font></li><ul><li><font style="font-size: 9pt;">层叠样式表(Cascading Style Sheets)是一种用来表现HTML文件样式的计算机语言</font></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">常用来对页面布局和样式进行修饰</font></span></li></ul><li><font style="font-size: 9pt;">JavaScript</font></li><ul><li><font style="font-size: 9pt;">JavaScript是一种能够被浏览器直接运行的解释型语言。</font></li><li><font style="font-size: 9pt;">常用来为网页添加动态功能，为用户提供更流畅美观的浏览效果和交互行为。</font></li></ul></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">URL的介绍</span></li><ul><li><span style="font-size: 9pt;">介绍：URL(Uniform Resource Locator)</span><span style="font-size: 9pt; font-weight: bold;">统一资源定位器</span><span style="font-size: 9pt;">、URL地址、也称为网页地址（网址）。</span></li><li><span style="font-size: 9pt;">作用：是因特网上资源所在地址的标准表示方式。</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">URL的构成：</span></li><ul><li><span style="font-size: 9pt;"><img src="/e_img/HTTP协议web服务器_files/Image.png" type="image/png" data-filename="Image.png" width="345"/></span></li><li><span style="font-size: 9pt;">例：</span><a href="https://docs.python.org/3/library/functions.html?highlight=callable#callable" style="font-size: 9pt;">https://docs.python.org/3/library/functions.html?highlight=callable#callable</a></li></ul><li><span style="font-size: 9pt;">绝对URL与相对URL</span></li><ul><li><span style="font-size: 9pt;">绝对url</span></li><ul><li><span style="font-size: 9pt;">从协议开始描述的例如：</span><a href="http://ftp://tv.dl1234.com:3100/xxxx30.mkv" style="font-size: 9pt;">ftp://tv.dl1234.com:3100/xxxx30.mkv</a><span style="font-size: 9pt;">；  一般从浏览器第一次输入url地址要用绝对url</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 1.45;">相对url</span></font></li><ul><li><span style="font-size: 9pt;">从服务器路径开始描述的；例如：/index.html  ；一般请求头包含的url都为相对url</span></li></ul></ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">静态url，伪静态，动态url的区别</font></span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">静态url：</font></span></li><ul><li><font style="font-size: 9pt;"><span style="line-height: 13.600000381469727px;">概念：<span style="line-height: 13.600000381469727px;">静态URL类似 域名/news/2012-5-18/110.html 我们一般称为真静态URL，每个网页有真实的物理路径，</span></span><span style="line-height: 1.45;">也就是真实存在服务器里的。</span></font></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">优点：<span style="line-height: 13.600000381469727px;">网站打开速度快，因为它不用进行运算；另外网址结构比较友好，利于记忆。</span></font></span></li><li><font style="font-size: 9pt;">缺点是：<span style="line-height: 1.45;">最大的缺点是如果是中大型网站，则产生的页面特别多，不好管理。至于有的开发者说占用</span><span style="line-height: 1.45;">硬盘空间大，我觉得这个可有忽略不计，占用不了多少空间的，况且目前硬盘空间都比较</span><span style="line-height: 1.45;">大。还有的开发者说会伤硬盘，这点也可以忽略不计。</span></font></li></ul><li><font style="font-size: 9pt;">动态URL：</font></li><ul><li><font style="font-size: 9pt;">概念：动态URL类似 域名/NewsMore.asp?id=5 或者 域名/DaiKuan.php?id=17，带有？号的URL，我们一般称为<span style="line-height: 1.45;">动态网址，每个URL只是一个逻辑地址，并不是真实物理存在服务器硬盘里的。</span></font></li><li><font style="font-size: 9pt;"><span style="line-height: 13.600000381469727px;">优点：<span style="line-height: 13.600000381469727px;">适合中大型网站，修改页面很方便，因为是逻辑地址，所以占用硬盘空间要比纯静态网站</span></span><span style="line-height: 1.45;">小。</span></font></li><li><font style="font-size: 9pt;">缺点是：<span style="line-height: 1.45;">因为要进行运算，所以打开速度稍慢，不过这个可有忽略不计，目前有服务器缓存技术可以</span><span style="line-height: 1.45;">解决速度问题。最大的缺点是URL结构稍稍复杂，不利于记忆。</span></font></li></ul><li><font style="font-size: 9pt;">伪静态URL</font></li><ul><li><font style="font-size: 9pt;">概念：伪静态URL类似 域名/course/74.html 这个URL和真静态URL类似。他是通过伪静态规则把动态URL伪装<span style="line-height: 1.45;">成静态网址。也是逻辑地址，不存在物理地址。</span></font></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">优点是：<span style="line-height: 13.600000381469727px;">URL比较友好，利于记忆。非常适合大中型网站，是个折中方案。</span></font></span></li><li><font style="font-size: 9pt;">缺点是：设置麻烦，服务器要支持重写规则，小企业网站或者玩不好的就不要折腾了。另外进行了伪<span style="line-height: 1.45;">静态网站访问速度并没有变快，因为实质上它会额外的进行运算解释，反正增加了服务器负</span><span style="line-height: 1.45;">担，速度反而变慢，不过现在的服务器都很强大，这种影响也可以忽略不计。还有可能会造</span><span style="line-height: 1.45;">成动态URL和静态URL都被搜索引擎收录，不过可以用robots禁止掉动态地址。</span></font></li></ul></ul></ul><li><span style="font-size: 9pt; font-weight: bold;">HTTP协议</span></li><ul><li><font style="font-size: 9pt;">概念：</font></li><ul><li><font style="font-size: 9pt;">超文本传输协议（HyperText Transfer Protocol）是一种应用层协议（基于TCP协议）。HTTP是万维网的数据通信的基础。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</font></li></ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">作用</font></span></li><ul><li><font style="font-size: 9pt;">在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来。而浏览器和服务器之间的传输协议是HTTP，所以：</font></li><ul><li><font style="font-size: 9pt;">HTML是一种用来定义网页的文本，会HTML，就可以编写网页；</font></li><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信。</font></span></li><li><font style="font-size: 9pt;">在TCP连接使用HTTP协议便能实现服务器和客户端之间的数据传输</font></li></ul></ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">HTTP协议规定的通信方式</font></span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">请求和响应的方式</font></span></li><ul><li><font style="font-size: 9pt;"><span style="line-height: 13.600000381469727px;">从客户端发出请求报文，客户端接收到请求报文后会通过传过来的请求内容做响应的处理后并返回响应内容，始终是以请求和响应的方式来完成通信</span></font></li></ul></ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">拓展：</font></span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">HTTPS协议就基于HTTP协议上进行构建了一套加密协议，用与安全传输</font></span></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">HTTP协议是一种不保存状态的协议，既使用HTTP新的响应产生，协议本身不会保存之前一切的请求或者响应报文的信息</font></span></li></ul></ul></ul><div><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold; line-height: 1.45;-evernote-highlight:true;">TCP的短连接与长连接</span></div><ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">短链接</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">客户端与服务端建立TCP连接后，如果完成一次读写操作后，由任意一端发起关闭操作</span></li></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">长连接</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">客户端与服务端建立TCP连接后，完成多次读写操作，待长时间不使用或者一端想要关闭连接时，发起关闭操作</span></li></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">短链接与长连接的优缺点</span></li><ul><li><span style="font-size: 9pt; -webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。</span><span style="font-size: 9pt; -webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">对于频繁请求资源的客户来说，较适用长连接。</span></li><li><span style="font-size: 9pt; -webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">client与server之间的连接如果一直不关闭的话，会存在一个问题，</span><span style="font-size: 9pt; -webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，</span><span style="font-size: 9pt; -webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；</span><span style="font-size: 9pt; -webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，</span><span style="font-size: 9pt; -webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">这样可以完全避免某个蛋疼的客户端连累后端服务。</span></li><li><span style="font-size: 9pt; line-height: 1.45;">短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。</span></li><li><span style="font-size: 9pt; line-height: 1.45;">但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</span></li></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 1.45;">短连接与长连接的应用场景（HTTP1.0应用的是短链接\HTTP1.1应用的是长连接）</span></li><ul><li><font style="font-size: 9pt;"><span style="-webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。</span><span style="-webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">每个TCP连接都需要三次握手，这需要时间，如果每个操作都是先连接，</span><span style="-webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，</span><span style="-webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">再次处理时直接发送数据包就OK了，不用建立TCP连接。</span><span style="-webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，</span><span style="-webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">而且频繁的socket 创建也是对资源的浪费。</span></font></li><li><font style="font-size: 9pt;"><span style="-webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，</span><span style="-webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，</span><span style="-webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，</span><span style="-webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; orphans: 3; widows: 3; line-height: 1.45;">那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</span></font></li></ul></ul><div><br/></div><div><span style="font-size: 18.399999618530273px; background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 18.399999618530273px; color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">web页面和web服务器</span></span></div><div><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">web页面的分类</span></font></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">作用</font></span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">客户端展示出来的服务界面</font></span></li></ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">静态页面</font></span></li><ul><li><font style="font-size: 9pt;">在用户请求时页面中的数据是固定的页面，即所有的数据都在返回的页面中</font></li></ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">动态页面</font></span></li><ul><li><font style="font-size: 9pt;">在用户请求时页面的数据即时放置到html网页中返回的页面，避免所有数据都表现在一个网页中，同一时间显示的数据量太巨大，一般会根据返回的页面中包含的连接继续请求其他的数据，动态的加载显示在网页上</font></li></ul></ul><li><span style="font-weight: bold;">web服务器</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">作用</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">一般也称网站服务器, 负责提供web服务的服务器，通过HTTP协议传给客户端（网页浏览器）,也叫HTTP服务器。</span></li></ul><li><span style="font-size: 9pt; line-height: 1.45;">Web服务器的构成： 硬件+程序</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">服务器硬件提供处理和计算的能力</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">服务器软件用来为客户端提供服务</span><br/></li></ul></ul></ul></div><div style="line-height: 13.600000381469727px;"></div><div><span style="background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-size: 14pt; font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">请求响应模式</span><br/></div><ul><li><font style="font-size: 10pt;"><span style="font-weight: bold; line-height: 13.600000381469727px;">请求响应模式--请求报文</span></font></li><ul><li><font style="font-size: 9pt;"><span style="line-height: 13.600000381469727px;">请求报文格式</span></font></li><ul><li><font style="font-size: 9pt;"><img src="/e_img/HTTP协议web服务器_files/Image [1].png" type="image/png" data-filename="Image.png" width="360"/></font></li></ul><li><font style="font-size: 9pt;">常用的请求方法</font></li><ul><li><font style="font-size: 9pt;">HTTP1.1支持8种请求方法： GET、POST、HEAD、OPTIONS、PUT、DELETE和TARCE。</font></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">这里简单介绍一下两种请求方法</font></span></li><ul><li><font style="font-size: 9pt;"><img src="/e_img/HTTP协议web服务器_files/Image [2].png" type="image/png" data-filename="Image.png" width="414"/></font></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">另外：POST请求的请求体没有长度限制；GET方法请求的请求关键字会有长度限制</font></span></li></ul></ul></ul><li><font style="font-size: 10pt;"><span style="font-weight: bold; line-height: 13.600000381469727px;">请求响应模式-响应报文</span></font></li><ul><li><font style="font-size: 9pt;"><span style="line-height: 1.45;">响应报文格式</span></font></li><ul><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">常用状态码和说明</font></span></li><ul><li><font style="font-size: 9pt;"><img src="/e_img/HTTP协议web服务器_files/Image [3].png" type="image/png" data-filename="Image.png" style="line-height: 1.45;" width="427"/></font></li><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">2XX 表成功接收/理解；      如200 OK3XX 表重定向 需要进一步的操作；   如302 Found4XX 表客户端错误；    如404 Not 、Found5XX 表服务器错误；    如503 Service Unavailable</font></span></li></ul></ul></ul><li><span style="font-weight: bold; line-height: 13.600000381469727px;"><font style="font-size: 10pt;">常用请求头部/响应头部</font></span></li><ul><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">请求头部 （客户端的请求头部）</font></span></li><ul><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">Host：请求主机的域名或者主机IP加端口</font></span></li><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">User-Agent：浏览器的身份</font></span></li><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">Accept-Encoding：接收的数据压缩方式（请求端进行可接受压缩方式说明）</font></span></li><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">Accept：表示可以接收的文件类型</font></span></li><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">Accept-language：表示可以接收的语言</font></span></li></ul><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">响应头部 </font></span></li><ul><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">Server ：表示服务器的身份</font></span></li></ul><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">通用头部 </font></span></li><ul><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">Connection：表示连接方式（长连接或者是短连接）</font></span></li></ul><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">实体头部 </font></span></li><ul><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">Content-Length ：服务器端表示响应体中的内容的字节长度为多少</font></span></li><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">Content-Type：服务器端表示响应体中包含的文件类型</font></span></li><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">Content-Encoding：服务器端表示响应体中包含的内容的压缩方式</font></span></li></ul></ul><li><span style="font-weight: bold; line-height: 13.600000381469727px;"><font style="font-size: 10pt;">请求体和响应体</font></span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">Body的数据类型由Content-Type头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。</span></li><li><span style="font-size: 9pt; line-height: 1.45;">当存在Content-Encoding时，Body数据是被压缩的，最常见的压缩方式是gzip，所以，看到Content-Encoding: gzip时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输</span></li></ul></ul><div><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">基于HTTP协议的请求-响应模式步骤</span></div><ul><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">步骤1：浏览器首先向服务器发送HTTP请求，请求包括：</font></span></li><ul><li><font style="font-size: 9pt;"><span style="line-height: 1.45;">（浏览器有时候由于处于对性能的考虑，会在第一次访问服务器的时候建立多个TCP连接，缓存起来，通信的时候只应用一个进行通</span><span style="line-height: 1.45;">                    </span><span style="line-height: 1.45;">信，其他的连接用来防止浏览器中途退出，再次发起和服务器的连接的时候还要再次建立三次握手的一个过程。）</span></font></li><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">方法：GET还是POST，GET仅请求资源，POST会附带用户数据；</font></span></li><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">路径：/full/url/path；</font></span></li><li><font style="font-size: 9pt;"><span style="line-height: 1.45;">域名：由Host头指定：Host:</span> <a href="http://www.sina.com/" style="line-height: 1.45;">www.sina.com</a></font></li><li><span style="line-height: 1.45;"><font style="font-size: 9pt;">以及其他相关的Header；</font></span></li><li><span style="line-height: 1.45;"><font style="font-size: 9pt;"> 如果是POST，那么请求还包括一个Body，包含用户数据</font></span></li></ul><li><font style="font-size: 9pt;"><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 1.45;">步骤2：服务器向浏览器返回HTTP响应，</span><span style="text-indent: 0pt; color: rgb(1, 1, 1); font-family: ����; line-height: 1.45;">响应包括：</span></font></li><ul><li><span style="text-indent: 0pt; color: rgb(1, 1, 1); font-family: ����; line-height: 1.45;"><font style="font-size: 9pt;">响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；</font></span></li><li><span style="text-indent: 0pt; color: rgb(1, 1, 1); font-family: ����; line-height: 1.45;"><font style="font-size: 9pt;">响应类型：由Content-Type指定；</font></span></li><li><span style="text-indent: 0pt; color: rgb(1, 1, 1); font-family: ����; line-height: 1.45;"><font style="font-size: 9pt;">以及其他相关的Header；</font></span></li><li><span style="text-indent: 0pt; color: rgb(1, 1, 1); font-family: ����; line-height: 1.45;"><font style="font-size: 9pt;">通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。</font></span></li></ul><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;">步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。</font></span></li></ul><div><font style="font-size: 14pt;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">构建web服务器</span></span></font></div><div><ul><li><font style="font-size: 10pt;"><span style="font-weight: bold; line-height: 13.600000381469727px;">web_sever现在的样子</span></font></li><ul><li><span style="line-height: 13.600000381469727px;">web_sever需要做的事情</span></li><ul><li><font style="font-size: 9pt;">web server需要同时处理静态和动态资源的请求</font></li><li><font style="font-size: 9pt;">web server还需要接收/响应 HTTP请求</font></li></ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">web_sever的构建方向</font></span></li><ul><li><font style="font-size: 9pt;">重构方向:将业务相关的代码从web server中抽离出来-应用</font></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-weight: bold; line-height: 13.600000381469727px;">静态界面和动态界面的响应过程对比</span></font></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">动态界面在处理静态和动态资源的时候往往交给应用框架来执行，sever主框架主要进行接受资源请求和响应</font></span></li><li><img src="/e_img/HTTP协议web服务器_files/Image [4].png" type="image/png" data-filename="Image.png" width="369"/></li></ul><li><span style="font-weight: bold;"><font style="font-size: 10pt;">WSGI协议 --用于统一服务器的设计规范</font></span></li><ul><li><font style="font-size: 9pt;">WSGI(Python Web Server Gateway Interface）概念</font></li><ul><li><font style="font-size: 9pt;">是为Python语言定义的Web服务器和Web应用程序(框架)之间的一种简单而通用的接口。</font></li></ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">WSGI的作用</font></span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">现代python web框架都支持WSGI，用来统一SEVER和应用框架之间的接口</font></span></li><li><font style="font-size: 9pt;"><span style="line-height: 13.600000381469727px;">统一服务器的接口设计让不同的应用框架和web_sever之间可以互相兼容</span></font></li><li><font style="font-size: 9pt;">这样可以使web server和web框架开发者专注自己的领域</font></li></ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">WSGI协议处理过程</font></span></li><ul><li><img src="/e_img/HTTP协议web服务器_files/Image [5].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="429"/> </li><li><span style="font-size: 9pt; line-height: 1.45;">1.</span><span style="font-size: 9pt; line-height: 1.45;">发送</span><span style="font-size: 9pt; line-height: 1.45;">http</span><span style="font-size: 9pt; line-height: 1.45;">请求动态资源给</span><span style="font-size: 9pt; line-height: 1.45;">web</span><span style="font-size: 9pt; line-height: 1.45;">服务器</span></li><li><span style="font-size: 9pt; line-height: 1.45;">2.web</span><span style="font-size: 9pt; line-height: 1.45;">服务器收到请求后通过</span><span style="font-size: 9pt; line-height: 1.45;">WSGI传递接收到的请求信息，和回调函数</span><span style="font-size: 9pt; line-height: 1.45;">给（应用程序框架）</span></li><li><span style="font-size: 9pt; line-height: 1.45;">3.</span><span style="font-size: 9pt; line-height: 1.45;">（应用程序框架）通过引用</span><span style="font-size: 9pt; line-height: 1.45;">WSGI</span><span style="font-size: 9pt; line-height: 1.45;">调用</span><span style="font-size: 9pt; line-height: 1.45;">web</span><span style="font-size: 9pt; line-height: 1.45;">服务器的方法，设置返回的状态和头信息</span></li><li><span style="font-size: 9pt; line-height: 1.45;">4.</span><span style="font-size: 9pt; line-height: 1.45;">调用后返回，此时</span><span style="font-size: 9pt; line-height: 1.45;">web</span><span style="font-size: 9pt; line-height: 1.45;">服务器保存了刚刚设置的信息</span></li><li><span style="font-size: 9pt; line-height: 1.45;">5.</span><span style="font-size: 9pt; line-height: 1.45;">（应用程序框架）查询数据库，生成动态页面的</span><span style="font-size: 9pt; line-height: 1.45;">body</span><span style="font-size: 9pt; line-height: 1.45;">信息</span></li><li><span style="font-size: 9pt; line-height: 1.45;">6.</span><span style="font-size: 9pt; line-height: 1.45;">把生成的</span><span style="font-size: 9pt; line-height: 1.45;">body</span><span style="font-size: 9pt; line-height: 1.45;">信息返回给</span><span style="font-size: 9pt; line-height: 1.45;">web</span><span style="font-size: 9pt; line-height: 1.45;">服务器</span></li><li><span style="font-size: 9pt; line-height: 1.45;">7.web</span><span style="font-size: 9pt; line-height: 1.45;">服务器把数据返回给浏览器</span></li></ul></ul></ul><ul><li><font style="font-size: 9pt;">WSGI服务器的路由功能</font></li><ul><li><font style="font-size: 9pt;">服务器可以根据用户的想要请求访问的路径，来决定下一步对文件执行的操作，这种情况叫做web服务器的路由功能</font></li></ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">WSGI协议的一些规范</font></span></li><ul><li><font style="font-size: 9pt;">WSGI 接口有<span style="font-weight: bold;">服务端</span>和<span style="font-weight: bold;">应用端</span>两部分，服务端也可以叫网关端，应用端也叫框架端</font></li><li><font style="font-size: 9pt;">服务端调用一个由应用端提供的可调用对象。如何调用这个对象，由服务端决定。『可调用对象』可能代表函数、方法、类或者实现了__call__方法的实例。</font></li><li><font style="font-size: 9pt;">WSGI规定 字符串用于请求/响应头部 ，字节用于请求和响应体部分</font></li></ul></ul><div><br/></div><div style="font-size: 9pt;"></div><div style="font-size: 9pt;"></div><div style="font-size: 9pt;"></div></div><div><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-family: ����; font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">服务中常用到的函数</span></div></div><div><ul><li><span style="color: rgb(1, 1, 1); font-weight: bold; line-height: 1.45;"><font style="font-size: 9pt;">回调函数</font></span></li><ul><li><font style="font-size: 9pt;"><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 1.45;">主动调用一个函数A时 给A传递了一个函数对象B作为A的参数，</span><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 1.45;">A会在合适的情况下调用B做一些事情B就是回调函数</span></font></li><ul><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;">例如：</font></span></li><ul><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;">re.sub(reg,func,data)</font></span></li><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;">def func(obj):    </font></span></li><ul><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;">return obj.group(1)+****+obj.group(3)</font></span></li></ul></ul></ul></ul><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;"><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px; font-weight: bold;">callable(obj)</span>     “判断一个对象是否可以被调用”</font></span></li><ul><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;">可以被调用的对象有哪些</font></span></li><ul><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 1.45;"><font style="font-size: 9pt;">function/method/lambda/class/instance实例（实现了call方法的）</font></span></li><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;">其中instance想要被调用需要实现__call__方法，再通过instance（）来调用__call__方法</font></span></li><ul><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 1.45;"><font style="font-size: 9pt;">x() 等价于 x.__call__()</font></span></li></ul><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;">f = lambda x:x+1   &quot;f为一个匿名函数，并且可以直接被调用&quot;</font></span></li></ul></ul><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;"><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px; font-weight: bold;">re = __import__(&quot;模块名&quot;)</span>     = import re</font></span></li><ul><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;"> &quot;导入一个模块,返回值为模块实例&quot;        ---- import 就是__import__实现的</font></span></li></ul><li><span style="color: rgb(1, 1, 1); font-family: ����; font-weight: bold; line-height: 13.600000381469727px;"><font style="font-size: 9pt;">re = getattr(模块的实例，“属性名”)</font></span></li><ul><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;">导入模块的一个属性（函数、类、变量），返回值为对应属性的实例</font></span></li></ul><li><font style="font-size: 9pt;"><span style="color: rgb(1, 1, 1); font-family: ����; font-weight: bold; line-height: 13.600000381469727px;">import sys</span></font></li><ul><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;">sys.argv    &quot;sys模块的argv变量记录了执行程序的时候传入的参数&quot;</font></span></li><li><span style="color: rgb(1, 1, 1); font-family: ����; line-height: 13.600000381469727px;"><font style="font-size: 9pt;">记录形式为列表，在列表中存储了包括了执行文件名和所有导入的参数</font></span></li></ul><li><font style="font-size: 9pt;"><span style="color: rgb(1, 1, 1); font-family: ����; font-weight: bold; line-height: 13.600000381469727px;">import urllib</span></font></li><ul><li><span style="color: rgb(1, 1, 1); font-family: ����;"><font style="font-size: 9pt;">urllib.parse.quote( )   &quot;将内容进行编码，返回值为编码后的结果&quot;</font></span></li><li><span style="color: rgb(1, 1, 1); font-family: ����;"><font style="font-size: 9pt;">urllib.parse.unquote()     “将已经编码的内容进行解码，返回值为解码后的结果”</font></span></li></ul></ul></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html>