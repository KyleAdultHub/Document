---
title: Requests模块-获取页面响应
date: "2017-01-11 21:00:00"
categories:
- python爬虫
- 爬虫基础
tags:
- 爬虫
toc: true
typora-root-url: ..\..\..
---

<html>
<body>
<div>
<span><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">Request模块的介绍</span></span></div><div><ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">request 库的特点</span></li><ul><li><span style="font-size: 9pt;">requests的底层实现就是urllib</span></li><li><span style="font-size: 9pt;">requests在python2 和python3中通用，方法完全一样</span></li><li><span style="font-size: 9pt;">requests简单易用</span></li><li><span style="font-size: 9pt;">requests能够自动帮助我们解压(gzip压缩的等)网页内容</span></li></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">requests的作用</span></li><ul><li><span style="font-size: 9pt;">发送网络请求，返回响应数据</span></li><li><span style="font-size: 9pt;">中文文档 API：</span><span style="text-indent: 0mm; min-height: 12pt;"><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" style="font-size: 9pt;">http://docs.python-requests.org/zh_CN/latest/user/quickstart.html</a></span></li></ul></ul><div><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">request/response的常用方法和属性</span></div><ul><li><span style="font-size: 10pt; font-weight: bold;">requests.get()    get请求</span></li><ul><li><span style="font-size: 9pt; font-weight: bold;">使用方法：</span></li><ul><li><span style="font-size: 9pt;">response = requests.get(url, headers=headers， params=params)    返回响应对象</span></li></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">get方法的参数</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">url：为请求的url地址</span></li><li><span style="font-size: 9pt;">headers：字典形式的命名参数，传递请求头。模拟浏览器获取想获取的数据，防止反扒检测；</span></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">示例：<span style="font-size: 9pt; line-height: 13.600000381469727px;">headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;}</span></span></font></li></ul><li><span style="font-size: 9pt;">params：字典形式命名参数，传递请求参数，获取想要获取的数据</span></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">示例：params<span style="font-size: 9pt; line-height: 13.600000381469727px;"> = {'wd':'长城'}</span></span></font></li></ul></ul></ul><li><span style="font-size: 10pt; font-weight: bold;">request.post()     post请求</span></li><ul><li><span style="font-size: 9pt; font-weight: bold;">使用方法：</span></li><ul><li><span style="font-size: 9pt;">response = requests.post(url, headers=headers, data= data)</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">post方法的参数</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">url：为请求的url地址（不包含锚点）</span></li><li><span style="font-size: 9pt;">headers：字典形式的命名参数，传递请求头。模拟浏览器获取想获取的数据，防止反扒检测；</span></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">示例：</span><span style="font-size: 9pt; line-height: 13.600000381469727px;">headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;}</span></font></li></ul><li><span style="font-size: 9pt;">data：</span></li><ul><li><span style="font-size: 9pt;">当时普通的post请求的时候，传递的参数是字典形式命名参数</span></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">Formdata参数示例：data</span><span style="font-size: 9pt; line-height: 13.600000381469727px;"> = {'wd':'长城'}</span></font></li></ul><li><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.600000381469727px;">当时ajax异步post请求的时候，传递的的字符串形式的参数</span></font></li><ul><li><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.600000381469727px;">Payload参数示例：data = json.dumps(</span><span style="font-size: 12px; line-height: 13.600000381469727px;">{'wd': '长城'}</span><span style="font-size: 12px; line-height: 13.600000381469727px;">)</span></font></li><li><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.600000381469727px;">还要加上请求头 ： <span style="font-size: 9pt; line-height: 13.600000381469727px;">'Content-Type': 'application/json'</span></span></font></li></ul></ul></ul></ul><li><font style="font-size: 12px;"><span style="font-size: 12px; font-weight: bold; line-height: 13.600000381469727px;">requests.utils   工具</span></font></li><ul><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">requests.utils.qoute(url)     将url编码</span></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">requests.utils.unqoute(url)     将url进行解码</span></font></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">parsed = requests.utils.urlparse(url)     将url进行  协议、ip+端口、文件路径、参数等的拆分</span></font></li><ul><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">parsed.scheme       获取协议名</span></li><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">parsed.netloc    获取</span><span style="line-height: 13.600000381469727px; font-size: 9pt;">ip+端口（或者是域名+端口）</span></li><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">parsed.path    获取路径</span></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">parsed.params     获取问号后面的参数</span></font></li></ul></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 1.45;">response 响应的常用属性和方法</span></li><ul><li><span style="font-size: 9pt; font-weight: bold;">response.text  </span> <span style="font-size: 9pt;">            </span><span style="font-size: 9pt; line-height: 1.45;">获取响应内容html字符串</span></li><ul><li><span style="line-height: 1.45; font-size: 9pt;">获取html字符串，结果是`str`类型</span></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 1.45;">其编码方式，</span><span style="font-size: 9pt; line-height: 1.45;">是requests根据响应头做出的有根据的推测，尝试使用这个编码方式来解码</span></font></li></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">response.encoding</span> <span style="font-size: 9pt; line-height: 13.600000381469727px;">              规定解码的格式</span></li><ul><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">可以在使用text属性获取响应字符串之前先规定编码格式，按照设定的编码格式进行解码</span></li></ul><li><span style="font-size: 9pt; font-weight: bold;">respones.content</span> <span style="font-size: 9pt;">        获取响应内容的二进制(bytes)数据</span></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">通常我们在获取到内容的时候尝试对二进制数据进行解码，</span><span style="font-size: 9pt; line-height: 13.600000381469727px;">下面三种方法能够解决后续我们100%的编解码的需求</span></font></li><ul><li><span style="font-size: 9pt;">response.content.deocde()           获取二进制响应内容并解码成为utf-8编码格式的字符串</span></li><li><span style="font-size: 9pt;">response.content.deocde(&quot;gbk&quot;)         获取二进制响应内容并解码成为gbk编码格式的字符串</span></li><li><span style="font-size: 9pt;">response.text      在使用content解码失败的时候，可以尝试让request去根据推测进行解码</span></li></ul></ul><li><span style="font-size: 9pt; font-weight: bold;">response.status_code      </span> <span style="font-size: 9pt;">查看响应状态码</span></li><li><span style="font-size: 9pt; font-weight: bold;">response.request.headers</span> <span style="font-size: 9pt;">    查看请求头</span></li><li><span style="font-size: 9pt; font-weight: bold;">response.headers</span> <span style="font-size: 9pt;">     查看响应头</span></li><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">response.request.url</span> <span style="font-size: 9pt; line-height: 13.600000381469727px;">    查看响应url</span></li><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">response.url</span> <span style="font-size: 9pt; line-height: 13.600000381469727px;">      查看请求url</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">响应的url可能与请求url不同，比如304重定向，响应的url为重定向的url</span></li></ul></ul></ul><div><br/></div><div><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">***找到想要请求url和请求参数的方法***</span></div><ul><li><span style="font-weight: bold; line-height: 13.600000381469727px;">寻找想要的url</span></li><ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">第一种情况：表单提交请求，并且表单有action属性</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">通过form表单的action属性/a标签的href属性来找到对应的请求url</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">form表单提交时获取表单中所有的name、value键值对</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">构造成字典，通过requests函数的data参数进行请求</span></li></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">第二种情况：通过ajax异步发出的请求（非action表单提交请求）</span></li><ul><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">查看抓包结果，存在我们想要最多的数据会是我们想要的响应，其url为主要的请求url</span></li><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">当有一些数据不存在该主要的请求中，那说明有js进行了其他异步请求获取了数据</span></li><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">我们可以先找到其他请求的响应，找到其url地址，其url地址一般有两种构建途径</span></li><ul><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">1.一般的情况下和url相关的信息会存在主请求的响应中，我们可以通过在主响应中获取其他请求的请求url关键字，进行url的构建</span></li><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">2.有的时候url地址或参数是通过js动态生成的，这时候，我们需要去寻找对应的js文件来观察js是怎样生成的动态url和参数等（参考下面）</span></li></ul></ul></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">寻找想要的js文件（当不是通过form表单的action/a标签href</span><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">属性</span><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">提交请求的时候）</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">找到进行url请求的js文件</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">第一种方法</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">使用开发者选择工具，点击会触发请求js的元素</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">点击右边的event Listener，会获取到对应的点击事件</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">点击事件所在的js文件</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">第二种方法</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">先了解js文件中会出现的关键字，一般可以查找url中动态参数名称；</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">通过点击右上角的菜单search all file</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">查找关键字，找到后点击进入对应的js文件</span></li></ul></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">会跳转到source界面，点击{}展开代码，显示文件全部的代码</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">找到想要找的事件函数，并在想要查看实现方法的函数前边加上断点</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">通过点击右边的调试工具，可以查看函数的具体执行步骤和实现方法</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">了解了实现的方法后，可以在爬虫请求的时候，实现同样的方法，然后生成参数和url地址，进行请求</span></li></ul></ul><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 14pt;"><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">使用代理获取响应</span></font></span></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">什么叫代理</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">在对网站爬取的时候，通过访问代理服务器，让代理服务器帮我们对目标服务器进行请求，然后通过代理服务器将响应返回给我们；</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">代理的作用</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">在需要大量的进行数据的爬取的时候</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">防止在同一时间，使用同一个ip地址对同一个服务器进行大量的访问，被反扒出来</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">在爬取网站的时候，通过代理服务器可以隐藏我们的真实ip地址，隐藏我们的身份，但是有的代理服务器不能隐匿我们的mac地址，如果想要隐匿我们的mac地址需要使用高匿代理服务器</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">代理服务器的原理</span></font></li><ul><li><span style="font-size: 9pt;"><img src="/e_img/Request模块-请求获取响应_files/Image.png" type="image/png" data-filename="Image.png" width="387"/></span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">正向代理/反向代理</span></font></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">正向代理</span></font></li><ul><li><span style="font-size: 9pt;">在我们请求代理服务器的时候，我们知道我们的最终目标ip地址，比如我们使用代理服务器爬取百度服务器的内容</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">反向代理</span></font></li><ul><li><span style="font-size: 9pt;">我们在请求服务器的时候，不知道最终目标ip地址，比如我们在访问nginx反向代理的服务器的时候，我们只是在访问nginx服务器，我们并不知道nginx去访问哪一个ip地址</span></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">requests使用代理</span></font></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">使用方法：</span></font></li><ul><li><span style="font-size: 9pt;">requests.get(url, proxies = proxies)</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">需要参数</span></font></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">proxies：字典类型命名参数，指定代理服务器支持的协议，和代理服务器的请求地址</span></font></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">示例：proxies = {&quot;协议&quot;:&quot;协议://ip:port&quot;}，传递代理服务器支持协议类型（http/https），和代理服务器的ip和端口</span></font></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">备注：<span style="font-size: 9pt; line-height: 13.600000381469727px;">proxies字典参数最多只能接受两个键值对，一个键是http，一个键是https，定义在进行http/https请求的时候分别使用的代理服务器</span></span></font></li></ul></ul></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 1.45;">代理服务器注意点：</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">http的url地址要使用http的代理，https的要使用https的代理</span></li><li><span style="font-size: 9pt; line-height: 1.45;">透明度低的代理能够被对方服务器找到我们的真实的ip，可能会导致代理的效果不明显</span></li></ul></ul><div><font style="font-size: 14pt;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">cookie与session的请求</span></span></font></div></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">cookie和session的区别</span></font></li><ul><li><span style="font-size: 9pt;">cookie存在浏览器本地，session在服务端</span></li><li><span style="font-size: 9pt;">cookie不安全，session不会将数据暴露在客户端，比较安全</span></li><li><span style="font-size: 9pt;">session占用性能，会加长请求的时间</span></li><li><span style="font-size: 9pt;">cookie存储是有上限的，session没有</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">请求带上cookies的好处</span></font></li><ul><li><span style="font-size: 9pt;">能够请求登陆后的页面</span></li><li><span style="font-size: 9pt;">带上cookie反反扒，用登录成功的cookie来进行伪造</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">伪造请求带上cookie的不好的地方</span></font></li><ul><li><span style="font-size: 9pt;">使用同一个cookie，不间断的访问同一个服务器的时候，可以被对方识别为爬虫</span></li><li><span style="font-size: 9pt;">解决方法：使用多个用户名密码，多账号，随机选用账号进行服务器的访问，模拟多人访问</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">模拟登录cookie/session请求的方法</span></font></li><ul><li><font style="font-size: 12px;"><span style="font-size: 12px; font-weight: bold; line-height: 13.600000381469727px;">第一种</span></font></li><ul><li><span style="font-size: 9pt;">session请求登录接口</span></li><ul><li><span style="font-size: 9pt;">实例化一个session对象</span></li><ul><li><span style="font-size: 9pt;">session = requests.session()</span></li></ul><li><span style="font-size: 9pt;">使用session请求登录接口，session对象会将响应中的cookie进行保存</span></li><ul><li><span style="font-size: 9pt;">session.post(url, data=data, headers=headers)</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">也可以使用get请求</span></li></ul></ul><li><span style="font-size: 9pt;">再使用session对象请求其他需要登录的url地址，会自动带上cookie进行访问</span></li><ul><li><span style="font-size: 9pt;">response =session.get(url, params=params, headers=headers)</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">session对象的作用</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">对响应的cookie进行保存，后面的访问会自动携带cookie</span></li></ul></ul></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">第二种</span></font></li><ul><li><span style="font-size: 12px; line-height: 13.600000381469727px;">要获取了登录后的cookie请求字符串</span></li><li><span style="font-size: 9pt;">headers中放cookie请求头字符串</span></li></ul><li><font style="font-size: 12px;"><span style="font-size: 12px; font-weight: bold; line-height: 13.600000381469727px;">第三种</span></font></li><ul><li><span style="font-size: 9pt;">把cookie的每一个name和value组成一个字典</span></li><li><span style="font-size: 9pt;">将字典传给requests请求中的cookies参数接收</span></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">获取response中的cookie的方法</span></font></li><ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">获取response中的cookie对象</span></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">response.cookies      获取respone的cookie对象</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">response.cookies只能获取服务器主动设置的cookie，不能获取我们手动创建的cookie</span></li><li><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.600000381469727px;">返回的数据类型是列表嵌套字典，每一个字典包含一个cookie的所有信息</span></font></li></ul></ul><li><font style="font-size: 12px;"><span style="font-size: 12px; font-weight: bold; line-height: 13.600000381469727px;">将cookie对象转化为字典类型的方法</span></font></li><ul><li><font style="font-size: 12px;"><span style="font-size: 12px; line-height: 13.600000381469727px;">requests.utils.dict_from_cookiejar(response.cookies)</span></font></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">将python字典类型转化为cookie对象类型</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">requests.utils.cookiejar_from_dict( {'key': value } )</span></li></ul></ul></ul><div><span style="font-size: 18.399999618530273px; background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 18.399999618530273px; color: rgb(50, 135, 18); font-weight: bold; line-height: 21.600000381469727px;-evernote-highlight:true;">requests请求常见问题</span></span></div><div><ul><li><span style="font-size: 10pt; line-height: 1.45;"> </span><span style="font-size: 10pt; font-weight: bold; line-height: 1.45;">SSl证书验证问题</span></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">问题产生原因</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">请求协议为https的网站需要向机构申请证书，这样用户才能直接通过https访问，但是有的网站（比如12306）的整数是自己研发的，这样浏览器不会在进行请求的时候，会产生一个证书异常，我们需要点击浏览器上的继续访问，来请求服务器，当我们使用爬虫来进行访问的时候，会直接报出异常</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">解决办法：</span></font></li><ul><li><span style="font-size: 9pt;">response = requests.get(&quot;</span><a href="https://www.12306.cn/mormhweb/" style="font-size: 9pt;">https://www.12306.cn/mormhweb/</a> <span style="font-size: 9pt;">&quot;, verify=False)</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">在请求非机构证书的网站的时候，我们需要在请求方法中加上verify=False 的参数，就不会报异常</span></li></ul></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">请求超时问题</span></font></li><ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">问题产生原因</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">当我们进行请求的时候，我们可能因为在请求摸一个url的时候产生一些异常，导致长时间没有请求成功，由于请求一直在进行，导致后面的程序无法正常执行，验证影响程序的效率或者导致程序终止</span></li></ul><li><span style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">解决办法</span></span></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">应用到的方法</span></font></li><ul><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">from retrying import retry   </span></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">@retry(stop_max_attempt_number=n)      装饰函数，表示函数如果报错将会再次执行，直到第n次如果依然报错，那将抛出异常</span></font></li><li><span style="font-size: 9pt;"> response = requests.get(url,timeout=10)     </span><span style="font-size: 9pt; line-height: 13.600000381469727px;">设置请求的超时时间，如果限定时间内没有请求成功，将会抛出异常</span></li><li><span style="line-height: 1.45; font-size: 9pt;">assert response.status_code == m      assert为断言关键字，如果后面的条件表达式为false将会排出异常</span></li></ul><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">示例：</span></li><ul><li><img src="/e_img/Request模块-请求获取响应_files/Image [1].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="312"/></li></ul></ul></ul></ul></div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">数据处理的技巧</span></span></div><div><ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 1.45;">字符串的格式化</span></li><ul><li><span style="line-height: 1.45; font-size: 9pt;">&quot;abc{}abc&quot;.format()</span></li><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">不同于%号的格式化，{ }方式的格式化，可以接收任意类型的格式化</span></li><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">format  接收的参数与格式化{ }的数量相等</span></li><li><span style="line-height: 13.600000381469727px; font-size: 9pt;">在通过字符串格式化构建url进行requests请求时候，尽量使用{ }来格式化，因为在浏览器会将url格式化，%有时候会按照特殊字符</span><span style="font-size: 9pt; line-height: 13.600000381469727px;">处理；</span></li></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 1.45;"> json数据与字符串之间的转化</span></li><ul><li><span style="line-height: 15.199999809265137px;">import json</span></li><li><span style="font-size: 9pt; line-height: 1.45;">json.dumps( dict)    把python类型字典数据转化为json字符串</span></li><li><span style="font-size: 9pt; line-height: 1.45;">json.loads('json' )    把json数据转化为python的字典类型</span></li></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 1.45;">扁平化赋值表达式</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">name = &quot;a&quot; if lang==b else &quot;c&quot;  </span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">if后面的条件如果成立，那么就把if前的值赋给str</span></li><li><span style="font-size: 9pt; line-height: 1.45;">否则if否面的条件不成立，就把else后的值赋给str</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">name = a and 'b' or 'c' </span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">如果a为true，name等于b</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">如果a为false，name等于c</span></li></ul></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 1.45;">列表推导式和字典推导式</span></li><ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">列表推倒式</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">[i for i in range(10) if i%2==0]</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">字典推导式</span></font></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">{i+1:i for i in range(10) if i%3==0}</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">注意：</span></font></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">在列表推导式中可以使用if判断，但是不能够使用else</span></li></ul></ul></ul><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">tips</span></span></div><ul><li><span style="font-size: 14px; font-weight: bold; line-height: 13.600000381469727px;">linux命令重命名</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">作用</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">可以将一段的linux命令，重名为其他比较短而且容易记忆的命令，方便我们的调用</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">设置方法</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">修改家目录下的.bashrc文件</span></li><li><span style="font-size: 9pt; line-height: 1.45;">添加  alias  新的命令='原命令 -选项/参数'</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">保存退出   source .bashrc</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">已经可以使用新的命令了 </span></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">将数据写入文件</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">文件存储内容的方法</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">with open('文件路径', encoding='utf-8') as f:</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">f.write(content)</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">encoding 如果文件不存在，相当于我们创建一个文件进行写入，我们可以通过encoding来指定写入内容的编码格式，如果不指定，可能会报错</span></li></ul></ul></ul></ul></ul><div><br/></div><div><span style="font-size: 18.399999618530273px; background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 18.399999618530273px; color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">常见的反扒思路</span></span></div><ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">尽量减少请求的次数</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">能抓列表页不抓详细页</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">保存html页面，有利于重复使用</span></li></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">多分析一个网站的不同类型页面</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">手机极速版页面</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">wap手机版页面</span></li><li><span style="font-size: 12px; line-height: 13.600000381469727px;">web网页</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">app抓包软件</span></li></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">进行请求伪装</span></li><ul><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">多带一些请求头，有的时候请求头带的不同，服务器返回的结果不同</font></span></li><li><font style="font-size: 9pt;">代理ip，设置代理ip池，定期更新代理ip池</font></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">在浏览器会根据cookie内容判断爬虫的时候，携带cookie（但是注意不要一直携带同一个cookie）</font></span></li><li><span style="line-height: 13.600000381469727px;"><font style="font-size: 9pt;">需要获取登录之后的数据的时候，要进行模拟登录，获取cookie后，在进行数据的获取</font></span></li></ul><li><span style="font-size: 10pt; font-weight: bold;">利用多线程/分布式（尽可能的快速抓取）</span></li><ul><li><span style="font-size: 9pt;">在可能的情况下尽可能的使用多线程和分布式爬虫</span></li></ul></ul></div><div><br/></div></div><div><br/></div></span>
</div></body></html>