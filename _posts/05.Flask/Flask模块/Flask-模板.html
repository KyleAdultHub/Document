模板的介绍
Flask模板的作用
处理业务逻辑和返回响应内容。在大型应用中，把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本。
模板的作用即是承担视图函数的另一个作用，即返回响应内容。 
模板渲染的介绍
模板其实是一个包含响应文本的文件，其中用占位符(变量)表示动态部分，告诉模板引擎其具体的值需要从使用的数据中获取
使用真实值替换变量，再返回最终得到的字符串，这个过程称为“渲染”
Flask是使用 Jinja2 这个模板引擎来渲染模板
渲染模板的函数
Flask提供的 render_template 函数封装了该模板引擎
render_template 函数的第一个参数是模板的文件名，后面的参数都是键值对，表示模板中变量对应的真实值。
使用模板的好处
视图函数只负责业务逻辑和数据处理(业务逻辑方面)
而模板则取到视图函数的数据结果进行展示(视图展示方面)
代码结构清晰，耦合度低
Jinja2与模板语言的概念
Jinja2：是 Python 下一个被广泛应用的模板引擎，是由Python实现的模板语言，他的设计思想来源于 Django 的模板引擎，并扩展了其语法和一系列强大的功能，其是Flask内置的模板语言。
模板语言：是一种被设计来自动生成文档的简单文本格式，在模板语言中，一般都会把一些变量传给模板，替换模板的特定位置上预先定义好的占位变量名。
模板-变量
模板中变量介绍
在模板中{{ variable }}结构表示变量，是一种特殊的占位符，告诉模板引擎这个位置的值，从渲染模板时使用的数据中获取；Jinja2除了能识别基本类型的变量，还能识别{}；
变量的表示方法
变量使用格式
{{ variable }}   变量代码块
代码块中的变量可以是任意python类型
过滤器
什么式过滤器
过滤器的本质就是函数。有时候我们不仅仅只是需要输出变量的值，我们还需要修改变量的显示，甚至格式化、运算等等，而在模板中是不能直接调用 Python 中的某些方法，那么这就用到了过滤器。
使用方式
过滤器的使用方式为
调用过滤器方法
带参数的过滤器：变量名 | 过滤器(参数)
{{variable | filter_name(*args)}}    参数可以是多个，用逗号隔开
不需要传递参数的过滤器：变量名| 过滤器
{{variable | filter_name}}
链式调用过滤器的方法
{{ "hello world" | reverse | upper }}
jinja2常见内建过滤器
字符串操作
safe：禁用转义
<p>{{ '<em>hello</em>' | safe }}</p>
capitalize：   把变量值的首字母转成大写，其余字母转小写
<p>{{ 'hello' | capitalize }}</p>
lower：把值转成小写
<p>{{ 'HELLO' | lower }}</p>
upper：把值转成大写
<p>{{ 'hello' | upper }}</p>
title：把值中的每个单词的首字母都转成大写
<p>{{ 'hello' | title }}</p>
reverse：字符串反转
<p>{{ 'olleh' | reverse }}</p>
format：格式化输出
<p>{{ '%s is %d' | format('name',17) }}</p>
striptags：渲染之前把值中所有的HTML标签都删掉
<p>{{ '<em>hello</em>' | striptags }}</p>
truncate: 字符串截断
<p>{{ 'hello every one' | truncate(9)}}</p>
列表操作
first：取第一个元素
<p>{{ [1,2,3,4,5,6] | first }}</p>
last：取最后一个元素
<p>{{ [1,2,3,4,5,6] | last }}</p>
length：获取列表长度
<p>{{ [1,2,3,4,5,6] | length }}</p>
sum：列表求和
<p>{{ [1,2,3,4,5,6] | sum }}</p>    列表求和
<p>{{  [{'name': 18}, {'name': 20}] | sum('name') }}</p>     列表嵌套字典字段求和
sort：列表排序
<p>{{ [6,2,3,1,5,4] | sort }}</p>
自定义过滤器
定义方式
定义过滤器函数(已do_lireverse自定义过滤器来举例)
def do_lireverse(li)
l = list(li)
l.reverse()
return l
注册过滤器函数
方式一：通过装饰器来注册自定义过滤器,在装饰的时候指定装饰器的名字
@ app.template_filter('lireverse')
方式二：直接将过滤器添加到过滤器列表中
app.add_template_filter(do_lireverse, 'li_reverse')
控制代码块
if语句
if语句作用
Jinja2 语法中的if语句跟 Python 中的 if 语句相似,后面的布尔值或返回布尔值的表达式将决定代码中的哪个流程会被执行
代码示例

循环语句  for
for 语句作用
我们可以在 Jinja2 中使用循环来迭代任何列表或者生成器函数
for语句的使用
普通的for循环代码块

循环语句结合if语句
作用
循环和if语句可以组合使用，以模拟 Python 循环中的 continue 功能
代码示例

在循环语句中可以访问的变量
访问方式
在循环内部,你可以使用一个叫做loop的特殊变量来获得关于for循环的一些信息
所有loop变量

loop.cycle的使用
使用cycle函数会在每次遍历输出变量的时候，给其添加一个前置变量
{% for my in my_list%}
{{loop.cycle('a','b','c')}}  -----   {{ my }}
{% endfor %}
循环内容之间的空格问题
现象
在使用循环遍历变量中的内容的时候，且每次遍历的内容不换行，在浏览器中显示的内容之间会有空格
解决办法
可以在循环的开始和结束位置放置一个 - 号去除for循环不换行情况下产生的空格
代码示例

宏的使用
什么是宏
把它看作 Jinja2 中的一个函数，它会返回一个模板或者HTML字符串
为了避免反复地编写同样的模板代码，出现代码冗余，可以把他们写成函数以进行重用
需要在多处重复使用的模板代码片段可以写入单独的文件，再包含在所有模板中，以避免重复
使用方法
定义宏（类似于python函数的定义）

调用宏（类似于python函数的调用）

宏的封装
宏的封装
把宏单独抽取出来，封装成html文件，其它模板中导入使用，文件名可以自定义macro.html

宏的调用

模板的继承和包含
模板的继承
模板继承的作用
模板继承是为了重用模板中的公共内容。一般Web开发中，继承主要使用在网站的顶部菜单、底部。这些内容可以定义在父模板中，子模板直接继承，而不需要重复书写。
相当于在父模板中挖个坑，当子模板继承父模板时，可以进行填充。
子模板使用extends指令声明这个模板继承自哪个模板
父模板中定义的块在子模板中被重新定义，在子模板中调用父模板的内容可以使用super()
父模板
父模板的定义
如果发现在多个子模板中重复使用了同一段代码， 那就应该把这段重复的内容定义到父模板中， 怎么定义到父模板中，就是使用block标签。
父模板的内容：
{% block '区域名' %} 
... 
{% endblock '区域名' %}   
示例：

子模板
子模板的定义
引入父模板，在父模板的框架中添加内容，在父模板的基础上进行模板文件的设计
子模板的首行：
首行一定是要导入的模板文件
{% extends '父模板文件名' %}
子模板的内容：
替换父模板中的block区域内容
{% block '父模板区域名' %} 
... 
{% endblock 父模板区域名 %}
在子模板中引用父模板中的内容
{{ super( ) }}
示例：

使用继承时候的注意点
不支持多继承
为了便于阅读，在子模板中使用extends时，尽量写在模板的第一行。
不能在一个模板文件中定义多个相同名字的block标签。
当在页面中使用多个block标签时，建议给结束标签起个名字，当多个block嵌套时，阅读性更好。
模板的包含
作用
它的功能是将另一个模板整个加载到当前模板中，并直接渲染。
模板导入的方法
{% include 'hello.html' %}
模板不存在异常
现象描述
包含在使用时，如果包含的模板文件不存在时，程序会抛出TemplateNotFound异常
解决办法
include的使用的时候可以加上ignore missing 关键字。如果包含的模板文件不存在，会忽略这条include语句。
代码示例
{% include 'hello.html' ignore missing %}
宏、继承、包含的总结
宏(Macro)、继承(Block)、包含(include)均能实现代码的复用。
继承(Block)的本质是代码替换，一般用来实现多个页面中重复不变的区域。
宏(Macro)的功能类似函数，可以传入参数，需要定义、调用。
包含(include)是直接将目标模板文件整个渲染出来。
模板中特有的变量
特有变量
你可以在自己的模板中访问一些Flask默认内置的函数和对象
config
可以从模板中直接访问Flask当前的config对象
{{ config.SQLALCHEMY_DATABASE_URI }}
request
就是flask中代表当前请求的request对象：
{{ request.url }}
session
为Flask的session对象
{{ session.new }}
g 变量
是单次请求的全局变量
{{ g.name ]}
url_for()
url_for()函数可以通过传入的函数名,解析对应的请求路径:
<a href='{{ url_for('index') }}'> 'back' </a>
url_for()函数可以通过传入的函数名,解析对应的请求路径(当视图函数需要传递参数):
<a href='{{ url_for('index'， param1) }}'> 'back' </a>
get_flashed_messages()
在视图函数中使用
flash()   向消息队列中添加一条消息
在模板中使用
get_flashed_messages()    从消息列队中将消息都取出来于一个列表中，并消费掉
模板中使用代码示例
{% for message in get_flashed_messages() %}
{{ message }}
{% endfor %}
注释
使用 {# #} 进行注释，注释的内容不会在html中被渲染出来
{# {{ name }} #}





