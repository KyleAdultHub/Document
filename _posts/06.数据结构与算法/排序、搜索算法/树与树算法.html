---
title: 树结构算法
date: "2016-07-26 22:00:00"
categories:
- 数据结构与算法
- 排序、搜索算法
tags:
- 数据结构与算法
toc: true
---

<html>
<body>
<div>
<span><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">树结构的介绍</span></font></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">树的概念</span></font></li><ul><li><span style="font-size: 9pt;">树（英语：tree）是一种抽象数据类型（ADT）的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">树的特点</span></font></li><ul><li><span style="font-size: 9pt;">每个节点有零个或多个子节点；</span></li><li><span style="font-size: 9pt;">没有父节点的节点称为根节点；</span></li><li><span style="font-size: 9pt;">每一个非根节点有且只有一个父节点；</span></li><li><span style="font-size: 9pt;">除了根节点外，每个子节点可以分为多个不相交的子树；</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">示例图：</span></font></li><ul><li><span style="font-size: 9pt;"><img src="/e_img//e_img//e_img/树与树算法_files/Image.png" type="image/png" data-filename="Image.png" width="228"/></span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">树结构应用的术语</span></font></li><ul><li><span style="font-size: 9pt;">节点的度：一个节点含有的子树的个数称为该节点的度；</span></li><li><span style="font-size: 9pt;">树的度：一棵树中，最大的节点的度称为树的度；</span></li><li><span style="font-size: 9pt;">叶节点或终端节点：度为零的节点；</span></li><li><span style="font-size: 9pt;">父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</span></li><li><span style="font-size: 9pt;">孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</span></li><li><span style="font-size: 9pt;">兄弟节点：具有相同父节点的节点互称为兄弟节点；</span></li><li><span style="font-size: 9pt;">节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</span></li><li><span style="font-size: 9pt;">树的高度或深度：树中节点的最大层次；</span></li><li><span style="font-size: 9pt;">堂兄弟节点：父节点在同一层的节点互为堂兄弟；</span></li><li><span style="font-size: 9pt;">节点的祖先：从根到该节点所经分支上的所有节点；</span></li><li><span style="font-size: 9pt;">子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</span></li><li><span style="font-size: 9pt;">森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">树的种类</span></font></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">无序树</span></font></li><ul><li><span style="font-size: 9pt;">树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">有序树</span></font></li><ul><li><span style="font-size: 9pt;">树中任意节点的子节点之间有顺序关系，这种树称为有序树；</span></li><li><span style="font-size: 9pt;">二叉树：每个节点最多含有两个子树的树称为二叉树；</span></li><ul><li><span style="font-size: 9pt;">完全二叉树：</span></li><ul><li><span style="font-size: 9pt;">对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;</span></li></ul><li><span style="font-size: 9pt;">平衡二叉树（AVL树）：</span></li><ul><li><span style="font-size: 9pt;">当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</span></li></ul><li><span style="font-size: 9pt;">排序二叉树（二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树）；</span></li></ul><li><span style="font-size: 9pt;">霍夫曼树（用于信息编码）：</span></li><ul><li><span style="font-size: 9pt;">带权路径最短的二叉树称为哈夫曼树或最优二叉树；</span></li></ul><li><span style="font-size: 9pt;">B树：</span></li><ul><li><span style="font-size: 9pt;">一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。</span></li></ul></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">树结构的应用场景</span></font></li><ul><li><span style="font-size: 9pt;">1.xml，html等，那么编写这些东西的解析器的时候，不可避免用到树</span></li><li><span style="font-size: 9pt;">2.路由协议就是使用了树的算法</span></li><li><span style="font-size: 9pt;">3.mysql数据库索引</span></li><li><span style="font-size: 9pt;">4.文件系统的目录结构</span></li><li><span style="font-size: 9pt;">5.所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构</span></li></ul></ul></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">树的存储方式</span></font></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">树的存储方式</span></font></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">第一种实现：</span><span style="font-size: 9pt;">顺序存储，将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流存储方式</span></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 13.600000381469727px;">第二种实现：以链式的方式存储</span></font></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">顺序存储示意图</span></font></li><ul><li><span style="font-size: 9pt;"><img src="/e_img//e_img//e_img/树与树算法_files/Image [1].png" type="image/png" data-filename="Image.png" width="249"/></span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">链式存储示意图</span></font></li><ul><li><span style="font-size: 9pt;"><img src="/e_img//e_img//e_img/树与树算法_files/Image [2].png" type="image/png" data-filename="Image.png" width="390"/></span></li><li><span style="font-size: 9pt;">由于对节点的个数无法掌握，常见树的存储表示都转换成二叉树进行处理，子节点个数最多为2</span></li></ul></ul><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">二叉树</span></font></div></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">二叉树的概念</span></font></li><ul><li><span style="font-size: 9pt;">二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">二叉树的性质</span></font></li><ul><li><span style="font-size: 9pt;">性质1:在二叉树的第i层上至多有2^(i-1)个结点（i&gt;0）</span></li><li><span style="font-size: 9pt;">性质2:深度为k的二叉树至多有2^k - 1个结点（k&gt;0）</span></li><li><span style="font-size: 9pt;">性质3:对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;</span></li><li><span style="font-size: 9pt;">性质4:具有n个结点的完全二叉树的深度必为 log2(n+1)</span></li><li><span style="font-size: 9pt;">性质5:对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">完全二叉树\满二叉树</span></font></li><ul><li><span style="font-size: 9pt;">(1)完全二叉树——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。</span></li><ul><li><span style="font-size: 9pt;"><img src="/e_img//e_img//e_img/树与树算法_files/Image [3].png" type="image/png" data-filename="Image.png" width="296"/></span></li></ul><li><span style="font-size: 9pt;">(2)满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。</span></li><ul><li><span style="font-size: 9pt;"><img src="/e_img//e_img//e_img/树与树算法_files/38.png" type="image/png" data-filename="38.png" width="206"/></span></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">二叉树节点的表示以及树的创建（完全二叉树）</span></font></li><ul><li><span style="font-size: 9pt; font-weight: bold;">节点的创建</span><span style="font-size: 9pt;">，通过使用Node类中定义三个属性，分别为elem本身的值，还有lchild左孩子和rchild右孩子</span></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">            class Node(object):</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">             </span> <span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51);">  &quot;&quot;&quot;节点类&quot;&quot;&quot;</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">               def __init__(self, item):</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                    self.item = item</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                    self.lchild = lchild</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                    self.rchild = rchild</span></div></div><div><ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">树的创建，</span><span style="font-size: 9pt; line-height: 13.600000381469727px;">创建一个树的类，并给一个root根节点，一开始为空，随后添加节点</span></li></ul><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">            class Tree(object):</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">         </span> <span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51);">      &quot;&quot;&quot; 树类 &quot;&quot;&quot;</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                def __init__(self, root=None):</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                    self.root = root</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                def add(self, item):</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">              </span><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51);">      &quot;&quot;&quot; 为树添加节点 &quot;&quot;&quot;</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                    node = Node(item)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                   </span><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51);"> # 如果树是空的，则对根节点赋值</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                    if self.root == None:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                        self.root = node</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                    else:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                        queue = []</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                        queue.append(self.root)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                        </span><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51);"># 对已有的节点进行层次遍历</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                        while queue:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                            </span><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51);"># 弹出队列的第一个元素</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                            cur = queue.pop(0)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                            if cur.lchild == None:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                                cur.lchild = node</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                                return</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                            elif cur.rchild == None:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                                cur.rchild = node</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                                return</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                            else:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                                </span><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51);"># 如果左右子树都不为空，加入队列继续判断</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                                queue.append(cur.lchild)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                                queue.append(cur.rchild)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                if __name__ == '__main__':</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                    tree = Tree()</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                    tree.add(0)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px;">                                        </span><span style="font-size: 9pt; background-color: rgb(251, 250, 248);">tree.add(1)</span></div></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">二叉树的遍历</span></font></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">树的遍历的概念</span></font></li><ul><li><span style="font-size: 9pt;">树的遍历是树的一种重要的运算。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次，我们把这种对所有节点的访问称为遍历（traversal）。那么树的两种重要的遍历模式是深度优先遍历和广度优先遍历,深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">深度优先遍历</span></font></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">深度优先遍历的特点</span></font></li><ul><li><span style="font-size: 9pt;">对于一颗二叉树，深度优先搜索(Depth First Search)是沿着树的深度遍历树的节点，尽可能深的搜索树的分支</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">深度遍历的三种方法</span></font></li><ul><li><span style="font-size: 9pt;">先序遍历（preorder）</span></li><li><span style="font-size: 9pt;">中序遍历（inorder）</span></li><li><span style="font-size: 9pt;">后序遍历（postorder）</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">先序优先遍历</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">介绍</span></li><ul><li><span style="font-size: 9pt;">先序遍历在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树</span></li><li><span style="font-size: 9pt;">顺序：根节点-&gt;左子树-&gt;右子树</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">代码</span></li><ul><li><img src="/e_img//e_img//e_img/树与树算法_files/Image [4].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="217"/></li></ul></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">中序优先遍历</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">介绍</span></li><ul><li><span style="font-size: 9pt;">中序遍历 在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树</span></li><li><span style="font-size: 9pt;">顺序：左子树-&gt;根节点-&gt;右子树</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">代码</span></li><ul><li><img src="/e_img//e_img//e_img/树与树算法_files/Image [5].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="201"/></li></ul></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">后序优先遍历</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">介绍</span></li><ul><li><span style="font-size: 9pt;">后序遍历 在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点</span></li><li><span style="font-size: 9pt;">顺序：左子树-&gt;右子树-&gt;根节点</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">代码</span></li><ul><li><img src="/e_img//e_img//e_img/树与树算法_files/Image [6].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="199"/></li></ul></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">三种方法遍历输出顺序</span></font></li><ul><li><span style="font-size: 9pt;"><img src="/e_img//e_img//e_img/树与树算法_files/Image [7].png" type="image/png" data-filename="Image.png" width="335"/></span></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">广度优先遍历</span></font></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">概念</span></font></li><ul><li><span style="font-size: 9pt;">从树的root开始，从上到下从从左到右遍历整个树的节点</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">代码</span></font></li><ul><li><img src="/e_img//e_img//e_img/树与树算法_files/Image [8].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="267"/></li></ul></ul></ul></div><div><br/></div></div><div><br/></div></div><div><br/></div></span>
</div></body></html>