---
title: Django-Model
date: "2016-08-01 22:00:00"
categories:
- 数据结构与算法
- 排序、搜索算法
tags:
- 数据结构与算法
toc: true
---

<html>
<head>
  <title>顺序表 / 链表</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/307941 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1068"/>
<h1>顺序表 / 链表</h1>

<div>
<span><div><div><span style="font-size: 18.399999618530273px; background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 18.399999618530273px; color: rgb(50, 135, 18); font-weight: bold; line-height: 21.600000381469727px;-evernote-highlight:true;">线性表之顺序表、链表</span></span></div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 21.600000381469727px;">线性表</span></font></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 21.600000381469727px;">在程序中，经常需要将一组元素作为整体管理和使用，需要创建这种元素组，用变量记录他们，传进传出函数等。一组数据中包含的元素个数可能发生变化(可以增加或删除元素)。</span></font></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 21.600000381469727px;">对于这种需求，最简单的解决方案便是将这样的一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系</span></font></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 21.600000381469727px;">这样的一组序列元素的组织形式，我们可以将其抽象为线性表</span></font></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 21.600000381469727px;">线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系，线性表是最基本的数据结构之一，在实际的程序应用非常广泛，他还经常被用作更复杂的数据结构和实现基础</span></font></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 21.600000381469727px;">根据线型表的实际存储形式，可以分为两种类型表：顺序表、链表等（接下来我们学习的数据结构都为线性表）</span></font></li></ul><li><span style="font-size: 10pt; font-weight: bold;">顺序表</span><span style="font-size: 12px; font-weight: bold;"> </span></li><ul><li><span style="font-size: 9pt;">将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。</span></li></ul><li><span style="font-size: 10pt; font-weight: bold;">链表</span><span style="font-size: 10pt;"> </span></li><ul><li><span style="font-size: 9pt;">将元素存放在通过链接构造起来的一系列存储块中</span></li></ul></ul><div><font color="#328712" style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">顺序表结构</span></font></div><div><ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 21.600000381469727px;">顺序表的基本存储形式</span></li><ul><li><img src="顺序表  链表_files/Image.png" type="image/png" data-filename="Image.png" style="font-size: 9pt; line-height: 1.45;" width="413"/></li><li><span style="font-size: 9pt; font-weight: bold; line-height: 1.45;">基本存储形式</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">图a表示的是顺序表的基本形式，会直接向内存申请一大块存储空间，数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，取数据的时候根据下标计算对应的地址</span></li><li><span style="font-size: 9pt; line-height: 1.45;">元素存储的物理地址（实际内存地址）可以通过存储区的起始地址Loc (e0)加上逻辑地址（第i个元素）与存储单元大小（c-比如整数所占内存的单元大小为4）的乘积计算而得，即：</span><span style="font-size: 9pt; line-height: 1.45;">Loc(ei) = Loc(e0) + c*i</span></li><li><span style="font-size: 9pt; line-height: 1.45;">访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)。</span></li></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">元素外置存储方式</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">如果元素的大小不统一，则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。</span></li><li><span style="font-size: 9pt; line-height: 1.45;">由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。</span><span style="font-size: 9pt; line-height: 1.45;">注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小，一般占4个字节单元。</span></li><li><span style="font-size: 9pt; line-height: 1.45;">图b这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。</span></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 21.600000381469727px;">顺序表基本结构</span></font></li><ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 21.600000381469727px;">顺序表的结构</span></li><ul><li><img src="顺序表  链表_files/Image [1].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="113"/></li><li><span style="font-size: 9pt; line-height: 1.45;">一个顺序表的完整信息包括两部分：1.表头；  2.元素存储区；</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">表头：记录</span><span style="font-size: 9pt; line-height: 1.45;">有</span><span style="font-size: 9pt; line-height: 1.45;">关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项；</span></li><li><span style="font-size: 9pt; line-height: 1.45;">元素存储区：记录的是表中的元素集合；</span></li></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">顺序表的两种基本实现方式</span></li><ul><li><img src="顺序表  链表_files/Image [2].png" type="image/png" data-filename="Image.png" style="font-size: 9pt; line-height: 1.45;" width="405"/></li><li><span style="font-size: 9pt; font-weight: bold; line-height: 1.45;">一体式结构</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象。</span></li><li><span style="font-size: 9pt; line-height: 1.45;">一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，元素存储区就固定了。</span></li></ul><li><span style="font-size: 12px; font-weight: bold; line-height: 13.600000381469727px;">分离式结构</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">图b为分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。</span></li></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 1.45;">元素存储区扩容替换</span></li><ul><li><span style="font-size: 9pt; line-height: 15.199999809265137px;">当元素存储区已经存满后，再向其中添加元素的时候需要扩容，这时候会向内存再申请一个新的容量更大的空间，将存储区替换为新的容量更大的空间，物理地址也响应的进行了变化</span></li><li><span style="font-size: 9pt; line-height: 1.45;">一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。</span></li><li><span style="font-size: 9pt; line-height: 1.45;">分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变，python的list就是应用的分离式元素外置的顺序表结构。</span></li></ul></ul></ul></ul></div><div><ul><li><span style="background-color: rgb(255, 255, 255);"><span style="font-size: 10pt; background-color: rgb(255, 255, 255); font-weight: bold; line-height: 13.600000381469727px;">顺序表的操作</span></span></li><ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">增加元素</span></li><ul><li><img src="顺序表  链表_files/Image [3].png" type="image/png" data-filename="Image.png" style="font-size: 9pt; line-height: 1.45;" width="341"/></li><li><span style="font-size: 9pt; line-height: 1.45;">a. 尾端加入元素，时间复杂度为O(1)</span></li><li><span style="font-size: 9pt; line-height: 1.45;">b. 非保序的加入元素（不常见），将原位置的元素放到尾端，时间复杂度为O(1)</span></li><li><span style="font-size: 9pt; line-height: 1.45;">c. 保序的元素加入，后面的元素依次向后诺一个单元，时间复杂度为O(n)（取得是最坏时间复杂度）</span></li></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">删除元素</span></li><ul><li><img src="顺序表  链表_files/Image [4].png" type="image/png" data-filename="Image.png" style="font-size: 9pt; line-height: 1.45;" width="364"/></li><li><span style="font-size: 9pt; line-height: 1.45;">a. 删除表尾元素，时间复杂度为O(1)</span></li><li><span style="font-size: 9pt; line-height: 1.45;">b. 非保序的元素删除（不常见），最后一个元素替换被删除元素的位置，时间复杂度为O(1)</span></li><li><span style="font-size: 9pt; line-height: 1.45;">c. 保序的元素删除，后面的元素依次向上移动一个单元，时间复杂度为O(n)</span></li></ul></ul></ul></div><div><ul><li><span style="background-color: rgb(255, 255, 255);"><span style="background-color: rgb(255, 255, 255); font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">python中的顺序表</span></span></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">python应用顺序表的数据类型</span></font></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">Python中的list和tuple两种类型采用了顺序表的实现技术，具有前面讨论的顺序表的所有性质。</span></li><li><span style="font-size: 9pt; line-height: 1.45;">tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似。</span></li></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">list结构的实现方法</span></li><ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">python-list应用的表结构</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">元素外置分离式动态顺序表</span></li></ul><li><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">python-list具有的特点</span></li><ul><li><span style="font-size: 9pt; line-height: 1.45;">基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)；</span></li><li><span style="font-size: 9pt; line-height: 1.45;">允许任意加入元素</span></li><li><span style="font-size: 9pt; line-height: 1.45;">元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序）</span></li><li><span style="font-size: 9pt; line-height: 1.45;">不断加入元素的过程中，表对象的标识（函数id得到的值）不变。</span></li></ul></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">li</span><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">st操</span><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">作的时间复杂度</span></font></li><ul><li><img src="顺序表  链表_files/Image [5].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="225"/></li></ul></ul></ul></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">链表结构</span></span></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 21.600000381469727px;">链表的详细介绍</span></font></li><ul><li><span style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">链表的存储形式</span></span></li><ul><li><span style="font-size: 9pt;">链表是一种常见的数据结构，是一种线性表，但是不像顺序表一样连续存储数据，而是在每一个节点里面存储下一个节点位置信息</span></li><li><span style="font-size: 9pt;">通过每个节点之间的关联行程了整个数据结构的关系</span></li><li><span style="font-size: 9pt;"><img src="顺序表  链表_files/Image [6].png" type="image/png" data-filename="Image.png" width="390"/></span></li></ul><li><span style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">为什么需要链表</span></span></li><ul><li><span style="font-size: 9pt;">顺序表的构建需要预先知道数据大小来申请连续的存储空间，而在进行空冲的时候又需要进行数据的 搬迁 ，所以使用起来并不灵活</span></li><li><span style="font-size: 9pt;">链表结构可以在充分利用计算机内存空间，时间灵活的内存动态管理</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">链表可以实现循环链表，可以用来无限循环遍历等场景</span></li><li><span style="font-size: 9pt;">python没有提供现成的链表形式的数据结构 ，要使用的时候我们需要自来定义该数据结构</span></li></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">节点实现的示例</span></font></li></ul><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: 微软雅黑;">            class SingleNode(object):</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: 微软雅黑;">                    &quot;&quot;&quot;单链表的结点&quot;&quot;&quot;</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: 微软雅黑;">                    def __init__(self,item):</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: 微软雅黑;">                            # item存放数据元素</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: 微软雅黑;">                            self.item = item</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: 微软雅黑;">                            # next是下一个节点的标识</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: 微软雅黑;">                            self.next = None</span></div></div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">链表的常见操作</span></font></li><ul><li><span style="font-size: 9pt;">is_empty() 链表是否为空</span></li><li><span style="font-size: 9pt;">length() 链表长度</span></li><li><span style="font-size: 9pt;">travel() 遍历整个链表</span></li><li><span style="font-size: 9pt;">add(item) 链表头部添加元素</span></li><li><span style="font-size: 9pt;">append(item) 链表尾部添加元素</span></li><li><span style="font-size: 9pt;">insert(pos, item) 指定位置添加元素</span></li><li><span style="font-size: 9pt;">remove(item) 删除节点</span></li><li><span style="font-size: 9pt;">search(item) 查找节点是否存在</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 1.45;">单向链表</span></font></li></ul></div></div><div><ul><ul><li><span style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">什么是单向链表</span></span></li><ul><li><span style="font-size: 9pt;">单向链表也叫单链表，是链表中最简单的一种形式，他的每个节点都包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后的一个节点的链接域则执行一个空值</span></li><li><span style="font-size: 9pt;"><img src="顺序表  链表_files/Image [7].png" type="image/png" data-filename="Image.png" width="380"/></span></li><li><span style="font-size: 9pt;">表元素域elem用来存放具体的数据。</span></li><li><span style="font-size: 9pt;">链接域next用来存放下一个节点的位置（python中的标识）</span></li><li><span style="font-size: 9pt;">变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。</span></li></ul><li><span style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">单链表的主要功能实现视图</span></span></li><ul><li><span style="font-size: 9pt;">头部添加元素</span></li><ul><li><span style="font-size: 9pt;"><img src="顺序表  链表_files/Image [8].png" type="image/png" data-filename="Image.png" width="509"/></span></li></ul><li><span style="font-size: 9pt;">指定位置添加元素</span></li><ul><li><span style="font-size: 9pt;"><img src="顺序表  链表_files/Image [9].png" type="image/png" data-filename="Image.png" width="519"/></span></li></ul><li><span style="font-size: 9pt;">删除节点</span></li><ul><li><span style="font-size: 9pt;"><img src="顺序表  链表_files/Image [10].png" type="image/png" data-filename="Image.png" width="464"/></span></li></ul></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">双向链表</span></font></li><ul><li><span style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">什么是双向链表</span></span></li><ul><li><span style="font-size: 9pt;">一种更复杂的链表，每个节点都有两个链接：一个指向前一个节点，当此节点为第一个几点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，指向空值、</span></li><li><span style="font-size: 9pt;"><img src="顺序表  链表_files/Image [11].png" type="image/png" data-filename="Image.png" width="392"/></span></li></ul><li><span style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">双向链表的主要功能实现视图</span></span></li><ul><li><span style="font-size: 9pt;">指定位置插入节点</span></li><ul><li><span style="font-size: 9pt;"><img src="顺序表  链表_files/Image [12].png" type="image/png" data-filename="Image.png" width="356"/></span></li></ul><li><span style="font-size: 9pt;">删除元素</span></li><ul><li><span style="font-size: 9pt;"><img src="顺序表  链表_files/Image [13].png" type="image/png" data-filename="Image.png" width="386"/></span></li></ul></ul></ul><li><span style="font-size: 10pt; font-weight: bold;">单向循环列表</span></li><ul><li><span style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">什么是单向循环链表</span></span></li><ul><li><span style="font-size: 9pt;">单链表的一个变形是单向循环链表，链表最后的一个节点的next域不再为None，而是指向链表的头节点</span></li><li><span style="font-size: 9pt;"><img src="顺序表  链表_files/Image [14].png" type="image/png" data-filename="Image.png" width="393"/></span></li></ul></ul><li><span style="font-size: 10pt; font-weight: bold;">链表和顺序表的对比</span></li><ul><li><span style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">功能对比</span></span></li><ul><li><span style="font-size: 9pt;">链表失去了顺序表随机读取的优点</span></li><li><span style="font-size: 9pt;">链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。</span></li></ul><li><span style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">链表与顺序表的各种操作复杂度对比</span></span></li><ul><li><img src="顺序表  链表_files/Image [15].png" type="image/png" data-filename="Image.png" width="375"/></li></ul></ul><li><span style="font-size: 10pt; font-weight: bold;">单向链表、双向链表、单向循环链表的代码实现</span></li><ul><li><a href="顺序表  链表_files/链表数据结构代码.zip"><img src="顺序表  链表_files/83bd684951c112459f742f338e2529e5.png" alt="链表数据结构代码.zip"></a></li></ul></ul></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">python中的字典的数据结构</span></font></div><div><ul><li><span style="font-size: 10pt; font-weight: bold;">python字典的实现方式</span></li><ul><li><span style="font-size: 9pt;">python中的字典，使用hash表实现，其实就是一个数组，跟列表类似，初始化长度为8，数组内放满了entry对象（记录了简键值对的对象），所有entry对象状态均为unused</span></li><li><span style="font-size: 9pt;">字典中的一个存储键值的对象称为一个entry，entry有三种状态，active，dummy（被删除）和unused</span></li></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">对字典进行操作的原理</span></li><ul><li><span style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">添加键值对</span></span></li><ul><li><span style="font-size: 9pt;">1、使用hash算法对key计算一个整数值，再拿整数值对字典长度取模//，得到下标，如果下标对应的entry状态为unused或dummy，则把键值对放此位置，并把状态改为active</span></li><li><span style="font-size: 9pt;">2、如果下标对应的entry状态为active，则使用开放寻址法，计算下一个下标，直到找到下标对应的entry状态为unused或dummy，则把键值对放此位置，并把状态改为active</span></li></ul><li><span style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">从字典查找和删除键值对</span></span></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 1.45;">1、使用hash算法对key计算一个整数值，再拿整数值对字典长度取模，得到下标</span></font></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 1.45;">2、如果下标对应的entry状态为unused，证明字典没有此键</span></font></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 1.45;">3、如果下标对应的entry状态为dummy，开放寻址法继续找，循环3步骤，直到找到状态为active的entry</span></font></li><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 1.45;">4、如果下标对应的entry状态为active，判断key是否相等，如果相等把状态改为dummy，如果不相等，开放寻址法继续找，循环4步骤</span></font></li><li><span style="font-size: 9pt;">5、如果最后找到状态为unused的entry，证明没有此键；</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 1.45;">注意：</span></span></font></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; line-height: 1.45;">字典之所以无序，是因为其顺序可能会在之后的操作发生变化，因为字典中一旦entry数量超过了长度了的2/3时，就会找一块新的地址进行移植行的扩容，会重新计算键的下标，存放的地址会进行改变，字典中的存储内容的顺序也会发生变化</span></font></li><li><span style="font-size: 9pt; line-height: 1.45;">扩容策略是entry数量超过了长度了的2/3时，当键值对数量小于5000时每次以4倍扩容（8-&gt;32-&gt;128...），大于5000时每次以2倍扩容</span></li></ul></ul></ul></div><div><br/></div></span>
</div></body></html> 