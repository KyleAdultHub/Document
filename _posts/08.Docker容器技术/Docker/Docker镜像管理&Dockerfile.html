---
title: Docker镜像管理&Dockerfile
date: "2018-06-20 22:00:00"
categories:
- Docker容器技术
- Docker
tags:
- Docker
toc: true
---

<html>
<body>
<div>
<span><div><div><span style="font-size: 18.6667px;background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 18.6667px; color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">Docker镜像</span></span></div><ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Docker镜像介绍</span></font></div></li><ul><li><div><span style="font-size: 9pt;">Docker镜像时一个只读的Docker容器模板，含有启动Docker容器所需的文件系统结构及其内容，因此是启动一个Docker容器的基础。</span></div></li><li><div><span style="font-size: 9pt;">Docker镜像的文件内容以及一些运行Docker容器的配置文件组成了Docker容器的静态文件系统运行环境-rootfs。</span></div></li><li><div><span style="font-size: 9pt;">可以理解为Docker容器的静态视角，Docker容器是Docker镜像的运行状态</span></div></li></ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">rootfs介绍</span></font></div></li><ul><li><div><span style="font-size: 9pt;">rootfs是Docker容器在启动时内部进程可见的文件系统，即Docker容器的根目录。</span></div></li><li><div><span style="font-size: 9pt;">rootfs通常包含一个操作系统运行所需的文件系统，例如可能包含典型的类Unix操作系统中的目录系统，/dev 、/proc 等,以及运行Docker容器所需的配置文件、工具等</span></div></li></ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">rootfs原理</span></font></div></li><ul><li><div><span style="font-size: 9pt;">在传统的Linux操作系统内核启动时，首先挂在一个只读的rootfs，当系统检测其完整性之后，再将其切换为读写模式</span></div></li><li><div><span style="font-size: 9pt;">在Docker架构中，当Docker daemon 为容器挂在rootfs时，沿用了Linux内核启动时的方法，将rootfs设计为只读模式。在挂在完毕之后，再利用连个挂在技术在只读rootfs上再挂在一个读写层。</span></div></li><li><div><span style="font-size: 9pt;">这样可读写层处于Docker容器文件系统的最顶层，其下可能联合挂在多个只读层，只有在Docker容器运行过程中文件系统发生变化时，才会吧变化的文件内容写到可读写层，并隐藏只读层中的老版本文件</span></div></li></ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Docker镜像的特点</span></font></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">分层</span></font></div></li><ul><li><div><span style="font-size: 9pt;">每个镜像都是由一系列的镜像层组成</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">写时复制</span></font></div></li><ul><li><div><span style="font-size: 9pt;">在多个容器之间共享镜像，每个容器在启动的时候并不需要单独复制一份镜像文件</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">内容寻址</span></font></div></li><ul><li><div><span style="font-size: 9pt;">根据文件内容来索引镜像和镜像层</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">联合挂载</span></font></div></li><ul><li><div><span style="font-size: 9pt;">可以在一个挂载点同时挂在多个文件系统，将挂载点的原目录与被挂在内容进行整合，使得最终课件的文件系统将会包含整合之后的各层的文件和目录</span></div></li></ul></ul></ul><div><font style="background-color: rgb(255, 250, 165);font-size: 14pt;-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">Docker镜像的构建</span></font></div><ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">使用commit创建镜像</span></font></div></li><ul><li><div><span style="font-size: 9pt;">docker commit命令只是提交容器镜像发生变更了的部分，即修改后的容器镜像与当前仓库中对应镜像之间的差异部分，这使得该操作实际需要提交的文件往往并不多</span></div></li></ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">使用commit实现步骤</span></font></div></li><ul><li><div><span style="font-size: 9pt;">1.根据输入的pause参数的设置确定是否暂停该Docker容器的运行</span></div></li><li><div><span style="font-size: 9pt;">2.将容器的可读写层导出打包，该读写层代表了当前运行容器的文件系统与当初启动该容器镜像之间的差异</span></div></li><li><div><span style="font-size: 9pt;">3.在层存储中逐层可读写层差异包</span></div></li><li><div><span style="font-size: 9pt;">4.更新镜像历史信息rootfs，并据此在镜像存储中创建一个新的镜像，记录其原数据</span></div></li><li><div><span style="font-size: 9pt;">5.如果指定了repository信息，则给上述镜像添加tag信息</span></div></li></ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">使用build构建镜像--client端</span></font></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">命令格式</span></font></div></li><ul><li><div><span style="font-size: 9pt;">docker build [OPTIONS]  PATH | URL |  -</span></div></li><ul><li><div><span style="font-size: 9pt;">path | URL : 其所指向的文件称为上下文context，context包含build Docker镜像过程中所需要的Dockerfile以及其他的资源文件。</span></div></li><li><div><span style="font-size: 9pt;">-t: 指定镜像的名字</span></div></li><li><div><span style="font-size: 9pt;">-f: 指定Dockerfile完整路径  和context的完整路径(可以是相对路径也可以是绝对路径) </span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">不同参数，Docker client处理的方法</span></font></div></li><ul><li><div><span style="font-size: 9pt;">1. 第一个参数为 &quot;-&quot;</span></div></li><ul><li><div><span style="font-size: 9pt;">sudo docker build -  Dockerfile</span></div></li><li><div><span style="font-size: 9pt;">sudo docker build -  context.tar.gz</span></div></li><li><div><span style="font-size: 9pt;">该情况，根据命令行输入参数对Dockerfile和context进行设置</span></div></li></ul><li><div><span style="font-size: 9pt;">2.第一个参数为URL，且是git repository URL</span></div></li><ul><li><div><span style="font-size: 9pt;">sudo docker build</span> <a href="http://github.com/creack/docker-firefox" style="font-size: 9pt;">github.com/creack/docker-firefox</a></div></li><li><div><span style="font-size: 9pt;">该情况，则调用git clone --depth 1 --recursive 命令克隆该Github repository，该操作会在本地的一个临时目录中进行</span></div></li><li><div><span style="font-size: 9pt;">命令你成功之后该目录会作为context传给Docker daemon，该目录中的Dockerfile会被用来进行后续构建Docker镜像</span></div></li></ul><li><div><span style="font-size: 9pt;">3.第一个参数为URL，不是git repository URL</span></div></li><ul><li><div><span style="font-size: 9pt;">该情况，会从该URL下载context，将其封装为一个io流，后面的处理与情况1相同</span></div></li></ul><li><div><span style="font-size: 9pt;">4.context为本地文件或者目录</span></div></li><ul><li><div><span style="font-size: 9pt;">sudo docker build -t vieux/apache:2.0     使用当前文件夹作为context</span></div></li><li><div><span style="font-size: 9pt;">cd /home/myapp/some/dir/really/deep &amp;&amp;</span></div></li><li><div><span style="font-size: 9pt;">sudo docker build -f /home/memyapp/dockerfiles/debug /home/me/myapp  使用指定的两目录分别作为Dockerfile  和context</span></div></li></ul><li><div><span style="font-size: 9pt;">备注：</span></div></li><ul><li><div><span style="font-size: 9pt;">如果目录中有.dockerignore文件，则将context中文件名满足其定义的规则的文件都从上传到列表中排出，不打包给Docker daemon。但唯一的例外是.dockerignore文件中若误写入了.dockerignore本身或者Dockerfile，将不产生作用。如果用户定义了tag，则对其指定的repository和tag进行验证</span></div></li><li><div><span style="font-size: 9pt;">完成了想关信息的设置之后，Docker client想Docker server发送buildHTTP请求，包含了所需的context信息</span></div></li></ul></ul></ul><li><div><font style="font-size: 12pt;"><span style="font-weight: bold;">使用build构建镜像--Docker server端</span></font></div></li><ul><li><div><span style="font-size: 9pt;">Docker server接受到HTTP请求后，其工作内容</span></div></li><ul><li><div><span style="font-size: 9pt;">1.创建临时目录，将context指定的文件系统解压到该目录下</span></div></li><li><div><span style="font-size: 9pt;">2.读取并解析Dockerfile</span></div></li><li><div><span style="font-size: 9pt;">3.根据解析出的Dockerfile遍历其中的所有指令，并分发到不同的模块去执行。Dockerfile特定的关键词都会映射到不同parser进行处理</span></div></li><li><div><span style="font-size: 9pt;">4.parser为上述每一个指令创建 一个对应的临时容器，在临时容器中执行当前指令，然后通过commit使用此容器生成一个镜像层</span></div></li><li><div><span style="font-size: 9pt;">5.Dockerfile中所有的指令对应的层的集合，就是此次build后的结果</span></div></li></ul></ul></ul><div><font style="background-color: rgb(255, 250, 165);font-size: 14pt;-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">Dockerfile</span></font></div><ul><li><div><span style="font-size: 12pt; font-weight: bold;">Dockerfile介绍</span></div></li><ul><li><div><span style="font-size: 9pt;">Dockerfile是在通过docker build命令构建自己的Docker镜像时需要使用到的定义文件。</span></div></li><li><div><span style="font-size: 9pt;">它允许用户使用基本的DSL语法来定义Docker镜像，每一条指令描述了构建镜像的步骤。</span></div></li><li><div><span style="font-size: 9pt;">用户可以使用这些统一的语法命令来根据需求进行配置，通过这份统一的配置文件，在不同的平台上进行分发，需要使用时就可以根据配置文件自动化构建，解决了开发人员构建镜像的复杂过程</span></div></li><li><div><span style="font-size: 9pt;">Dockerfile与镜像配合使用，使Docker在构建时可以充分利用镜像功能进行缓存，大大提升了Docker的使用效率</span></div></li></ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Dockerfile生成镜像的过程</span></font></div></li><ul><li><div><span style="font-size: 9pt;">本地主机的一个包含Dockerfile的目录中的所有内容作为上下文</span></div></li><li><div><span style="font-size: 9pt;">上下文通过docker build命令传入到Docker daemon后，便开始按照Dockerfile中的内容构造镜像</span></div></li><li><div><span style="font-size: 9pt;">按照Dockerfile中的指令进行读条指令的构建镜像，除了from指令，其他每一条指令都会在上一条指令所生成的镜像的基础上执行，执行完成后生辰一个新的镜像层</span></div></li><li><div><span style="font-size: 9pt;">镜像层不断的覆盖原来的镜像形成新的镜像。Dockerfile所生成的最终镜像就是在基础镜像上叠加一层层的镜像层组建的</span></div></li></ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Docker指令</span></font></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">介绍</span></font></div></li><ul><li><div><span style="font-size: 9pt;">基本格式 </span></div></li><ul><li><div><span style="font-size: 9pt;">INSTRUCTION arguments</span></div></li></ul><li><div><span style="font-size: 9pt;">命令格式</span></div></li><ul><li><div><span style="font-size: 9pt;">在Dockerfile中，指令INSTRUCTION不区分大小写，但是为了参数区分，推荐大写。</span></div></li><li><div><span style="font-size: 9pt;">Docker会顺序执行Dockerfile中的指令，第一条指令必须为FROM指令，它用于指定构建镜像的基础镜像</span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">ENV 指令</span></font></div></li><ul><li><div><span style="font-size: 9pt;">格式</span></div></li><ul><li><div><span style="font-size: 9pt;">ENV &lt;KEY&gt; =&lt;value&gt;   </span></div></li></ul><li><div><span style="font-size: 9pt;">说明</span></div></li><ul><li><div><span style="font-size: 9pt;">ENV指令可以为镜像创建出来的容器生命环境变量</span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">FROM指令</span></font></div></li><ul><li><div><span style="font-size: 9pt;">格式：</span></div></li><ul><li><div><span style="font-size: 9pt;">FROM &lt;iamge&gt;[:&lt;tag&gt;]</span></div></li></ul><li><div><span style="font-size: 9pt;">说明</span></div></li><ul><li><div><span style="font-size: 9pt;">FROM指令的功能是为后面的指令提供基础镜像，因为一个有效的Dockerfile必须以FROM指令你做为第一条非注释指令</span></div></li><li><div><span style="font-size: 9pt;">在Dockerfile中，FROM指令可以出现多次，这样会构建多个镜像。</span></div></li><li><div><span style="font-size: 9pt;">在每个镜像创建完成后，Docker命令行界面会输入该镜像的ID。若FROM指令中的参数tag为空，默认tag是latest</span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">COPY指令</span></font></div></li><ul><li><div><span style="font-size: 9pt;">格式</span></div></li><ul><li><div><span style="font-size: 9pt;">COPY &lt;src&gt; &lt;dest&gt;</span></div></li></ul><li><div><span style="font-size: 9pt;">说明</span></div></li><ul><li><div><span style="font-size: 9pt;">COPY指令复制&lt;src&gt;所指向的文件或者目录，将它添加到新场景中，复制的文件或目录在镜像中的路径是&lt;dest&gt;</span></div></li><li><div><span style="font-size: 9pt;">&lt;src&gt;所指定的源可以有多个，但必须在上下文中，即必须是上下文根目录的相对路径</span></div></li><li><div><span style="font-size: 9pt;">若结尾符为/则表示为目录，否则为文件</span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">ADD指令</span></font></div></li><ul><li><div><span style="font-size: 9pt;">格式</span></div></li><ul><li><div><span style="font-size: 9pt;">ADD &lt;src&gt;  &lt;dest&gt;</span></div></li></ul><li><div><span style="font-size: 9pt;">说明</span></div></li><ul><li><div><span style="font-size: 9pt;">ADD与COPY指令在功能上很相似，都支持复制本地文件到镜像的功能，但ADD指令还支持其他的功能</span></div></li><li><div><span style="font-size: 9pt;">&lt;src&gt;可以是一个指向一个网络文件的URL ，若&lt;dest&gt;为目录，则URL必须是完全路径，这样可以获得该网路文件的文件名filename，该文件会被复制添加到&lt;dest&gt;/&lt;file_name&gt;，若URL中的文件为压缩文件，默认不会被解压提取</span></div></li><li><div><span style="font-size: 9pt;">&lt;src&gt;还可以指向一个本地压缩归档文件，该文件再复制到容器中时会被解压提取</span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">RUN指令</span></font></div></li><ul><li><div><span style="font-size: 9pt;">格式 </span></div></li><ul><li><div><span style="font-size: 9pt;">RUN &lt;command&gt;  (shell 格式)</span></div></li><li><div><span style="font-size: 9pt;">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]  (exec格式，推荐使用)</span></div></li></ul><li><div><span style="font-size: 9pt;">说明</span></div></li><ul><li><div><span style="font-size: 9pt;">RUN指令会在前一条命令创建出镜像的基础上创建一个容器，并在容器中运行命令，</span></div></li><li><div><span style="font-size: 9pt;">在命令运行后提交容器为新的镜像，新镜像被Dockerfile中的下一条指令使用</span></div></li><li><div><span style="font-size: 9pt;">通常在需要创建镜像后安装依赖的情况下使用</span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">CMD指令</span></font></div></li><ul><li><div><span style="font-size: 9pt;">格式</span></div></li><ul><li><div><span style="font-size: 9pt;">CMD &lt;command&gt;  (shell格式)</span></div></li><li><div><span style="font-size: 9pt;">CMD  [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]  (exec格式，推荐格式)</span></div></li><li><div><span style="font-size: 9pt;">CMD [&quot;param1&quot;, &quot;param2&quot;]  (为ENTRUPOINT指令提供参数)</span></div></li></ul><li><div><span style="font-size: 9pt;">说明</span></div></li><ul><li><div><span style="font-size: 9pt;">CMD命令提供容器运行时的默认值，这些默认值可以是一条指令，也可以是一些参数。</span></div></li><li><div><span style="font-size: 9pt;">一个Dockerfile中可以有多条CMD指令，但是只有最后一条CMD指令有效。</span></div></li><li><div><span style="font-size: 9pt;">CMD [&quot;param1&quot;, &quot;param2&quot;] 格式只有在CMD指令和ENTRYPOINT指令配合使用，CMD指令中的参数会添加到ENTRYPOINT指令中</span></div></li><li><div><span style="font-size: 9pt;">使用shell和exec格式时，命令在容器中运行的方式和RUN指令相同，不同在于，RUN指令在构建镜像时执行命令，并生成新的镜像，CMD指令在构建镜像的时候不执行任何命令，而是在容器启动的时候默认将CMD指令作为第一条执行命令。</span></div></li><li><div><span style="font-size: 9pt;">如果用户在命令行界面运行docker run命令时指定了命令参数，则会覆盖CMD指令中的命令</span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">ENTRYPOINT指令</span></font></div></li><ul><li><div><span style="font-size: 9pt;">格式</span></div></li><ul><li><div><span style="font-size: 9pt;">ENTRYPOINT  &lt;command&gt;  (shell格式)</span></div></li><li><div><span style="font-size: 9pt;">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]  (exec格式，推荐格式)</span></div></li></ul><li><div><span style="font-size: 9pt;">说明</span></div></li><ul><li><div><span style="font-size: 9pt;">ENTRYPOINT指令和CMD指令类似，都可以让容器每次启动时候执行相同的命令</span></div></li><li><div><span style="font-size: 9pt;">一个Dockerfile中可以有多条ENTRYPOINT指令，但只有最后一条ENTRYPOINT指令有效</span></div></li><li><div><span style="font-size: 9pt;">当使用shell格式时，ENTRYPOINT指令会忽略任何CMD指令和docker run命令参数，并运行在/bin/sh -c 中。</span></div></li><li><div><span style="font-size: 9pt;">当使用 exec格式，docker run传入的命令参数会覆盖CMD指令的内容并附加到ENTRYPOINT指令参数中</span></div></li><li><div><span style="font-size: 9pt;">CMD可以是参数，也可以是指令，ENTRYPOINT只能是命令，灵台docker run命令你提供的运行命令参数可以覆盖CMD，但是不能覆盖ENTRYPOINT</span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">ONBUILD</span></font></div></li><ul><li><div><span style="font-size: 9pt;">格式</span></div></li><ul><li><div><span style="font-size: 9pt;">ONBUILD  [INSTRUCTION]</span></div></li></ul><li><div><span style="font-size: 9pt;">说明</span></div></li><ul><li><div><span style="font-size: 9pt;">添加一个将来执行的触发器指令到镜像中。当该镜像作为FROM指令的参数时，这些触发器指令就会在FROM指令执行的时候加入到构建的过程中</span></div></li><li><div><span style="font-size: 9pt;">尽管任何一个指令都可以被注册成一个触发器钟灵，但是ONBUILD指令中不能包含ONBUILD指令，并且不会触发FROM和MAINTAINER指令</span></div></li><li><div><span style="font-size: 9pt;">ONBUILD经常用于需要在创建镜像的时候，需要对导入的镜像做一些文件的导入，一些批处理的时候</span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">LABLE</span></font></div></li><ul><li><div><span style="font-size: 9pt;">格式</span></div></li><ul><li><div><span style="font-size: 9pt;">LABEL multi.label1=&quot;value1&quot; \</span></div></li><ul><li><div><span style="font-size: 9pt;">multi.label2=&quot;value2&quot; \</span></div></li><li><div><span style="font-size: 9pt;">other=&quot;value3&quot;</span></div></li></ul></ul><li><div><span style="font-size: 9pt;">说明</span></div></li><ul><li><div><span style="font-size: 9pt;">label是累积的，包括FROM镜像的lable。</span></div></li><li><div><span style="font-size: 9pt;">如果Docker遇到一个label/key已经存在，那么新的值将覆盖这个label/key。</span></div></li><li><div><span style="font-size: 9pt;">要查看一个镜像的label，使用docker inspect命令。</span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">EXPOSE</span></font></div></li><ul><li><div><span style="font-size: 9pt;">格式</span></div></li><ul><li><div><span style="font-size: 9pt;">EXPOSE &lt;port1&gt; &lt;port2&gt;</span></div></li></ul><li><div><span style="font-size: 9pt;">说明</span></div></li><ul><li><div><span style="font-size: 9pt;">EXPOSE宿主机需要暴露哪些端口</span></div></li><li><div><span style="font-size: 9pt;">在启动容器时需要通过-P（注意是大写），Docker主机会自动分配一个端口转发到指定的端口；使用-p，则可以具体指定哪个本地端口映射过来。</span></div></li></ul></ul><li><div><span style="font-size: 12px;"><span style="font-size: 12px; font-weight: bold;">WORKDIR</span></span></div></li><ul><li><div><span style="font-size: 12px;">格式</span></div></li><ul><li><div><span style="font-size: 9pt;"><span style="font-size: 9pt;">WORKDIR &lt;path&gt;</span></span></div></li></ul><li><div><span style="font-size: 12px;">说明</span></div></li><ul><li><div>指定了RUN CMD  ENTRYPOINT等命令运行的目录</div></li></ul></ul></ul><li><div><span style="font-size: 12pt; font-weight: bold;">Dockerfile示例</span></div></li><ul><li><div><img src="/e_img/Docker镜像管理、Dockerfile_files/Image.png" type="image/png" data-filename="Image.png" width="443"/></div></li></ul></ul><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">使用Dockerfile注意</span></font></div><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">标签易读</span></font></div></li><ul><li><div><span style="font-size: 9pt;">例如：docker  build  -t  =&quot;ruby:2,0-onbuild&quot;</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">谨慎选择基础镜像</span></font></div></li><ul><li><div><span style="font-size: 9pt;">尽量选择当前官方镜像库中的镜像</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">充分利用缓存</span></font></div></li><ul><li><div><span style="font-size: 9pt;">尽量让相同的指令放在前面，充分使用缓存的结果</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">正确使用ADD和COPY命令</span></font></div></li><ul><li><div><span style="font-size: 9pt;">尽量使用COPY命令</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">CMD和ENTRPOINT合用</span></font></div></li><ul><li><div><span style="font-size: 9pt;">尽量使用CMD和ENTRYPOINT指令配合，可以使用exec格式的ENNTRYPOINT指令设置固定的默认命令参数，然后使用CMD指令设置可变的参数</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">不要在Dockerfile中做端口映射</span></font></div></li><ul><li><div><span style="font-size: 9pt;">如果在Dockerfile中做端口映射，导致只能在主机上启动一个容器</span></div></li><li><div><span style="font-size: 9pt;">应该使用EXPOSE 80    只暴露端口，另做映射</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">使用Dockerfile共享Docker镜像</span></font></div></li></ul><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html>