---
title: 随机、批量梯度下降
date: "2018-12-22 12:44:00"
categories:
- 机器学习
- 机器学习
tags:
- 机器学习
- 梯度下降
toc: true
typora-root-url: ..\..\..
---

### 1. 随机梯度下降

#### 什么时候需要使用随机梯度下降

当使用传统的梯度下降的时候，每一次的迭代，都会去计算所有样本的误差总和，这样就造成了很大的运算量，以及会加载很多的数据，这样当数据量很大的时候，我们的硬件资源也很难满足我们的需求。所以，如果我们一定需要一个大规模的训练集，我们可以尝试使用随机梯度下降法来代替批量梯度下降法。

#### 随机梯度下降算法

**单一实例的代价函数**

$\operatorname { cost } \left( \theta , \left( x ^ { ( i ) } , y ^ { ( i ) } \right) \right) = \frac { 1 } { 2 } \left( h _ { \theta } \left( x ^ { ( i ) } \right) - y ^ { ( i ) } \right) ^ { 2 }$

**参数优化步骤**

1. 首先对训练集数据进行随机洗牌，使训练集数据的顺序打乱，目的是防止相邻数据相似导致优化相抵消

2. 循环遍历每一个实例，通过其代价函数的导数来优化参数θ

   for $i = 1 : m \{$
   $\theta : = \theta _ { j } - \alpha \left( h _ { \theta } \left( x ^ { ( i ) } \right) - y ^ { ( i ) } \right) x _ { j } ^ { ( i ) }$
   (for $j = 0 : n )$
   }}

随机梯度下降算法在每一次计算之后便更新参数 θ ，而不需要首先将所有的训练集求和，在梯度下降算法还没有完成一次迭代时，随机梯度下降算法便已经走出了很远。但是这样的算法存在的问题是，不是每一步都是朝着”正确”的方向迈出的。因此算法虽然会逐渐走向全局最小值的位置，但是可能无法站到那个最小值的那一点，而是在最小值点附近徘徊

![1545455857456](/img/1545455857456.png)

### 2.小批量梯度下降

小批量梯度下降算法是介于批量梯度下降算法和随机梯度下降算法之间的算法，每计算常数 b 次训练实例，便更新
一次参数 θ 。 

for $i = 1 : m \{$
$\theta : = \theta _ { j } - \alpha \frac { 1 } { b } \sum _ { k = i } ^ { i + b - 1 } \left( h _ { \theta } \left( x ^ { ( k ) } \right) - y ^ { ( k ) } \right) x _ { j } ^ { ( k ) }$
(for $j = 0 : n )$
$i + = 10$

}}

通常我们会令 b 在 2-100 之间。这样做的好处在于，我们可以用向量化的方式来循环 个训练实例，如果我们用的
线性代数函数库比较好，能够支持平行处理，那么算法的总体表现将不受影响（与随机梯度下降相同）。

### 3.随机梯度下降收敛

在批量梯度下降中，我们可以像普通的梯度下降那样，可以令代价函数 J 为迭代次数的函数，绘制图表，根据图表来判断梯度下降是否收敛。但是，在大规模的训练集的情况下，这是不现实的，因为计算代价太大了。

在随机梯度下降中，我们在每一次更新 θ 之前都计算一次代价，然后每 x 次迭代后，求出这 x 次对训练实例计算代价的平均值，然后绘制这些平均值与 x 次迭代的次数之间的函数图表

![1545456689203](/../../../../software/typora/Typora/1545456689203.png)

当我们绘制这样的图表时，可能会得到一个颠簸不平但是不会明显减少的函数图像（如上面左下图中蓝线所示）。我们可以增加 α 来使得函数更加平缓，也许便能看出下降的趋势了（如上面左下图中红线所示）；或者可能函数图表仍然是颠簸不平且不下降的（如洋红色线所示），那么我们的模型本身可能存在一些错误

果我们得到的曲线如上面右下方所示，不断地上升，那么我们可能会需要选择一个较小的学习率 α。

我们也可以令学习率随着迭代次数的增加而减小，例如令：

$\alpha = \frac { \text { const } } { \text { iteration Number } + \text { const } 2 }$

随着我们不断地靠近全局最小值，通过减小学习率，我们迫使算法收敛而非在最小值附近徘徊。 但是通常我们不需
要这样做便能有非常好的效果了，对 α 进行调整所耗费的计算通常不值得

![1545456798949](/img/1545456798949.png)

