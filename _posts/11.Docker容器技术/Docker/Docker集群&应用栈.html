---
title: Docker镜像管理&Dockerfile
date: "2018-06-19 22:00:00"
categories:
- Docker容器技术
- Docker
tags:
- Docker
toc: true
---

<html>
<body>
<div>
<span><div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">Docker集群&amp;应用栈的介绍</span></font></div><ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Docker集群&amp;应用栈概念</span></font></div></li><ul><li><div><span style="font-size: 9pt;">Docker的设计理念是希望用户能够保证一个容器只运行一个进程，即只提供一种服务。</span></div></li><li><div><span style="font-size: 9pt;">然而对于用户而言，单一的容器是无法满足需求的。通常用户需要利用多个容器，分别提供不同的服务，并在不同的容器间互相通信，最后形成一个docker集群，以实现特定功能。</span></div></li><li><div><span style="font-size: 9pt;">基于Docker集群构建的应用我们成为Docker应用栈</span></div></li></ul></ul><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">搭建应用栈所需过程</span></font></div><ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对应用栈的描述</span></font></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">示例</span></font></div></li><ul><li><div><span style="font-size: 9pt;">搭建一个包含6个节点的Docker-Web服务应用栈，其中包括一个代理节点、两个Web应用节点、一个主数据库节点及两个从数据库节点</span></div></li></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">图例:</span></font></div></li><ul><li><div><span style="font-size: 9pt;"><img src="/e_img/Docker集群、应用栈_files/Image.png" type="image/png" data-filename="Image.png" width="294"/></span></div></li></ul></ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">获取各节点所需的镜像</span></font></div></li><ul><li><div><span style="font-size: 9pt;">镜像可以是Docker Hub中已经存在的镜像</span></div></li><li><div><span style="font-size: 9pt;">镜像也可以是自己提交的Docker镜像</span></div></li></ul><li><div><span style="font-weight: bold; font-size: 14pt;">网络调通</span></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">应用栈容器节点之间的互联（同主机下实现，如果跨主机还需解决跨主机通信）</span></font></div></li><ul><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">实现节点互联命令</span></font></div></li><ul><li><div><span style="font-size: 9pt;">docker run [OPTIONS]  --link name:alias  --name Name IMAGE [COMMAND] [ARG1, ......]   </span></div></li><ul><li><div><span style="font-size: 9pt;">alias: 给接受的容器起一个别名可以应用于快速链接</span></div></li><li><div><span style="font-size: 9pt;">name: 容器名称</span></div></li></ul></ul><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">示例</span></font></div></li><ul><li><div><span style="font-size: 9pt;">sudo docker run -it --name redis-slave1 --link redis-master:master redis /bin/bash</span></div></li></ul><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">通过--link互联的优点</span></font></div></li><ul><li><div><span style="font-size: 9pt;">通过--link方式互联，不但可以避免容器的IP端口暴露到外网所导致的安全问题，还可以放置容器在启动后Ip地址变化导致的访问失效</span></div></li><li><div><span style="font-size: 9pt;">可以防止容器重启导致容器IP地址变化访问失效，它的原理类似于DNS服务器的域名和地址映射</span></div></li><li><div><span style="font-size: 9pt;">当容器的IP地址发生变化时，Docker将自动维护映射关系中的IP地址</span></div></li></ul><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">查看连接信息</span></font></div></li><ul><li><div><span style="font-size: 9pt;">cat /etc/host</span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">确定应用栈的启动顺序及暴露外网访问端口</span></font></div></li><ul><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">确定启动顺序(先启动被连接的节点)：</span></font></div></li><ul><li><div><span style="font-size: 9pt;">redis-master--&gt;redis-slave--&gt;APP1/2--&gt;HAProxy</span></div></li></ul><li><div><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">暴露Ip端口</span></font></div></li><ul><li><div><span style="font-size: 9pt;">sudo docker run -it --name HProxy --link APP1:APP1 --link APP2:APP2 -p 6301:6301 haproxy /bin/bash</span></div></li></ul></ul><li><div><span style="font-weight: bold;">网络链接涉及到的参数</span></div></li><ul><li><div><span style="font-size: 9pt;">--iptables: 将容器的端口暴露给外部主机，就是通过iptables做DNAT(目的地址转换)实现的。以及Docker容器间的通信业是通过修改FORWARD链中响应的itables规则的策略。当设为false时Docker daemon将不会改变你的宿主机上的iptable规则，默认是true。</span></div></li><li><div><span style="font-size: 9pt;">--icc: 当容器都链接到了docker0网线上，容器已经属于一个子网，已经满足通信前提，这时容器间是否可以通信取决于FORWARD链中的ACCEPT规则，设置为false，规则会被置位DROP，Docker荣期间的相互通信就被禁止，这种情况，想让容器互联一定要使用--link选项，容器间默认为true。注意修改FORWARD规则一定要设置--iptables为true</span></div></li><li><div><span style="font-size: 9pt;">--ip--forward: 在Docker容器和外界通信过程中，还设计数据包的多网卡间转发，需要内核将ip--forward功能打开，即将ip_forward系统参数设置为1</span></div></li></ul><li><div><span style="font-weight: bold;">修改Docker daemon的启动参数</span></div></li><ul><li><div><span style="font-size: 9pt;">修改/etc/detault/docker</span></div></li></ul></ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">应用栈容器节点间的配置/程序文件编辑</span></font></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">查看挂在volume位置(如果镜像事先已经配置了volume)</span></font></div></li><ul><li><div><span style="font-size: 9pt;">sudo docker inspect --format &quot;{{ Volumes }}&quot;  CONTAINER</span></div></li><ul><li><div><span style="font-size: 9pt;">return: map[/data:/var/docker/vfs/dir/xxx]    /data 为容器中的共享目录， /var/docker/vfs/dir/xxx 为主机的volume目录</span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">启动时指定volume共享目录(如果镜像中没有配置共享目录)</span></font></div></li><ul><li><div><span style="font-size: 9pt;">sudo docker run -it -v ~/projects:/usr/src/app  ubuntu   </span></div></li><ul><li><div><span style="font-size: 9pt;">~/projects: 为主机的volume目录</span></div></li><li><div><span style="font-size: 9pt;">/usr/src/app: 为容器中的volume目录</span></div></li></ul></ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">应用共享volume目录进行配置文件的编辑</span></font></div></li><ul><li><div><span style="font-size: 9pt;">1.在volume中编辑配置/项目文件，或者将配置/项目文件传到volume目录</span></div></li><li><div><span style="font-size: 9pt;">2.通过volume目录的文件来启动程序</span></div></li></ul></ul></ul><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">Docker在各阶段的作用</span></font></div><ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">在开发阶段</span></font></div></li><ul><li><div><span style="font-size: 9pt;">镜像的使用使得构建开发环境变得简单统一</span></div></li></ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">在测试阶段</span></font></div></li><ul><li><div><span style="font-size: 9pt;">可以直接使用开发所构建的镜像进行测试，直接免除了测试环境构建的烦恼，也消除了因为环境不一致所带来的漏洞问题</span></div></li></ul><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">在部署和运维阶段</span></font></div></li><ul><li><div><span style="font-size: 9pt;">与以往代码级别的部署不同，利用Docker可以进行容器级别的部署，把应用及其依赖环境打包成跨平台、轻量级、可移植的容器来进行部署</span></div></li></ul></ul><div><br/></div></div><div><br/></div></span>
</div></body></html>