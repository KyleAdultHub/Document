---
title: python多线程爬虫
date: "2016-12-13 20:00:00"
categories:
- python爬虫
- 爬虫基础
tags:
- 爬虫
toc: true
typora-root-url: ..\..\..
---



<html>
<body>
<div>
<span><div><font style="font-size: 14pt;"><span style="font-size: 14pt; background-color: rgb(255, 250, 165); color: rgb(50, 135, 18); font-weight: bold;-evernote-highlight:true;">多线程爬虫所需应用</span></font></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">Queue（对列对象）</span></font></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">介绍Queue</span></font></li><ul><li><span style="font-size: 9pt;">Queue是python中的标准库，可以直接import Queue引用;队列是线程间最常用的交换数据的形式。</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold;">Queue的作用</span></font></li><ul><li><span style="font-size: 9pt;">python下多线程</span><span style="font-size: 9pt; line-height: 1.45;">对于资源的处理，加锁是个重要的环节，因为python原生的list,dict等，都是not thread safe的，所以使用Queue，</span><span style="font-size: 9pt; line-height: 1.45;">可以不用手动添加资源锁就能解决资源竞争的问题</span><span style="font-size: 9pt; line-height: 1.45;">。</span></li><li><span style="font-size: 9pt; line-height: 1.45;">在使用Queue进行参数传递的时候，只有Queue列队中有数据，线程就可以获得并执行任务，不需要等待其他线程对数据的处理并传递，更方便数据的传递和处理；</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">使用方法</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">创建队列对象</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">from queue import Queue</span></li><li><span style="font-size: 9pt;">queue = Queue(maxsize = n)        创建一个最大容量为n的queue列队</span></li></ul><li><span style="font-size: 9pt;">将一个数值放在队列中</span></li><ul><li><span style="font-size: 9pt;">queue.put( )      向列队中添加任务，列队满后会阻塞等待</span></li><li><span style="font-size: 9pt;">myqueue.put_nowait( )    想列队中添加任务，列队满后会报错</span></li></ul><li><span style="font-size: 9pt;">将一个数值从队列中取出</span></li><ul><li><span style="font-size: 9pt;">queue.get( )     从列队中取出任务</span></li><li><span style="font-size: 9pt;">queue.get([block[, timeout]])        从列队中取出任务，超时后会报错</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">备注：从列队取出任务后，列队计数并不会减一，需要标记任务task_done</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">任务完成，列队技术减一</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">queue.task_done( )      列队计数减一</span></li></ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">列队任务计数不为0时，阻塞线程</span></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">Queue.join( )                 列队如果不为空，阻塞主线程</span></li></ul><li><span style="font-size: 9pt;">其他查询列队状态的方法</span></li><ul><li><span style="font-size: 9pt;">Queue.qsize()              返回队列当前计数大小</span></li><li><span style="font-size: 9pt;">Queue.empty()           如果队列为空，返回True,反之False</span></li><li><span style="font-size: 9pt;">Queue.full()                  如果队列满了，返回True,反之False</span></li><li><span style="font-size: 9pt;">Queue.full                    与 maxsize 大小对应</span></li></ul></ul></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">线程的使用（复习）</span></font></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">创建子线程</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">import threading</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">t1 = threading.Thread(target=function, args=(, ))</span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">将子线程设置为守护进程</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">t1.setDeamon(True)   </span></li></ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">启动子线程</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">t1.start( )</span></li></ul></ul><li><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">线程的使用策略</span></li><ul><li><font style="font-size: 9pt;"><span style="font-size: 9pt; font-weight: bold; line-height: 13.600000381469727px;">使用策略</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">创建不同功能任务需求的列队</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">在处理时间较长的功能函数处，使用比较多的线程</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">在处理时间比较快的函数处，使用比较少的线程</span></li><li><span style="font-size: 9pt; line-height: 1.45;">少创建一些线程，线程之间会进行资源的竞争，导致请求失败率增加</span></li><li><span style="font-size: 9pt; line-height: 1.45;">多设置一些最大请求次数，增加请求成功的几率</span></li><li><span style="font-size: 9pt; line-height: 1.45;">将失败的请求，任务，防止到一个列表/对列中，单独再对失败的进程进行统一执行</span></li></ul></ul></ul></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 14pt;"><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">断点续爬的思想</span></font></span></div><div><ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">场景</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">在我们爬取数据的时候，想要先停止爬取，将爬取的状态和数据保存，并想要下次爬取的时候再接着当前的状态继续爬取</span></li></ul><li><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold; line-height: 13.600000381469727px;">实现方法</span></font></li><ul><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">可以保存当前的所有的queue列队，在程序结束之前将queue对象存储到redis中</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">当下次启动程序的时候，从redis数据库中读取上次停止之前的queue对象</span></li><li><span style="font-size: 9pt; line-height: 13.600000381469727px;">程序判断queue对象的状态，是否全部为空，如果不为空，那么便不需要再重新获取参数想queue列队中添加，直接接着之前的queue的装填进行爬取</span></li></ul></ul></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 14pt;"><span style="background-color: rgb(255, 250, 165); font-size: 14pt; color: rgb(50, 135, 18); font-weight: bold; line-height: 13.600000381469727px;-evernote-highlight:true;">多线程爬虫代码实例</span></font></span></div><div><ul><li><img src="/e_img/python多线程爬虫_files/Image.png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="879"/></li><li><img src="/e_img/python多线程爬虫_files/Image [1].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="880"/></li><li><img src="/e_img/python多线程爬虫_files/Image [2].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;" width="881"/></li></ul></div><div><br/></div></span>
</div></body></html>